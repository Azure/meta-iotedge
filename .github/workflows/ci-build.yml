name: Yocto build

on:
  pull_request:
    branches:
      - main
      - kirkstone
  push:
    branches:
      - main
      - kirkstone
  workflow_dispatch:
    inputs:
      skip_qemu:
        description: "Skip QEMU validation (faster, packages only)"
        type: boolean
        default: false
  workflow_call:
    inputs:
      ref:
        description: "Git ref to checkout (tag or branch)"
        type: string
        required: false
      skip_qemu:
        description: "Skip QEMU validation"
        type: boolean
        default: false
      retry_workflow:
        description: "Workflow to retry on timeout (defaults to ci-build.yml)"
        type: string
        default: "ci-build.yml"
    outputs:
      template:
        description: "Template used for build"
        value: ${{ jobs.build.outputs.template }}

permissions:
  contents: read
  packages: read

concurrency:
  group: yocto-build-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build:
    name: Build and validate
    runs-on: ubuntu-22.04
    timeout-minutes: 360
    outputs:
      template: ${{ steps.set-template.outputs.template }}
    container:
      image: ghcr.io/${{ github.repository_owner }}/meta-iotedge-devcontainer:scarthgap
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      options: --user root
    env:
      BB_SERVER_TIMEOUT: "600"
      BB_COMMAND_TIMEOUT: "300"
      DEVCONTAINER: "1"
      YOCTO_CACHE_DIR: /workspaces/yocto-cache
    steps:
      - name: Determine template from branch
        id: set-template
        run: |
          case "${{ github.base_ref || github.ref_name }}" in
            kirkstone) echo "template=kirkstone" >> "$GITHUB_OUTPUT" ;;
            *) echo "template=scarthgap" >> "$GITHUB_OUTPUT" ;;
          esac

      - name: Create build user
        run: useradd -m builder

      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || '' }}

      - name: Fix permissions
        run: |
          chown -R builder:builder "${GITHUB_WORKSPACE}"
          git config --global --add safe.directory "${GITHUB_WORKSPACE}"

      - name: Prepare cache directories
        run: |
          mkdir -p "${YOCTO_CACHE_DIR}/downloads" "${YOCTO_CACHE_DIR}/sstate-cache"
          chown -R builder:builder "${YOCTO_CACHE_DIR}"

      - name: Restore sstate cache
        uses: actions/cache/restore@v4
        with:
          path: sstate-cache.tar.zst
          key: yocto-sstate-${{ steps.set-template.outputs.template }}-${{ hashFiles('conf/templates/*/local.conf.sample', 'conf/templates/*/bblayers.conf.sample') }}
          restore-keys: |
            yocto-sstate-${{ steps.set-template.outputs.template }}-

      - name: Restore downloads cache
        uses: actions/cache/restore@v4
        with:
          path: downloads.tar.zst
          key: yocto-downloads-${{ hashFiles('recipes-*/**/*.bb', 'recipes-*/**/*.inc') }}
          restore-keys: |
            yocto-downloads-

      - name: Decompress caches
        run: |
          if [[ -f sstate-cache.tar.zst ]]; then
            echo "Decompressing sstate cache..."
            tar -I 'zstd -T0 -d' -xf sstate-cache.tar.zst -C "${YOCTO_CACHE_DIR}/"
            rm sstate-cache.tar.zst
            echo "Sstate cache size: $(du -sh ${YOCTO_CACHE_DIR}/sstate-cache 2>/dev/null | cut -f1 || echo 'empty')"
          fi
          if [[ -f downloads.tar.zst ]]; then
            echo "Decompressing downloads cache..."
            tar -I 'zstd -T0 -d' -xf downloads.tar.zst -C "${YOCTO_CACHE_DIR}/"
            rm downloads.tar.zst
            echo "Downloads cache size: $(du -sh ${YOCTO_CACHE_DIR}/downloads 2>/dev/null | cut -f1 || echo 'empty')"
          fi

      - name: Fix cache permissions
        run: chown -R builder:builder "${YOCTO_CACHE_DIR}"

      - name: Fetch layers
        run: sudo -E -u builder ./scripts/fetch.sh "${{ steps.set-template.outputs.template }}"

      - name: Build
        id: build
        env:
          SKIP_QEMU: ${{ inputs.skip_qemu }}
          TEMPLATE: ${{ steps.set-template.outputs.template }}
        run: |
          if [[ "${SKIP_QEMU}" == "true" ]]; then
            sudo -E -u builder ./scripts/build.sh "${TEMPLATE}"
          else
            sudo -E -u builder ./scripts/build.sh "${TEMPLATE}" --with-qemu
          fi

      - name: Run QEMU validation
        if: ${{ !inputs.skip_qemu }}
        run: sudo -E -u builder ./scripts/validate-qemu.sh "${{ steps.set-template.outputs.template }}"

      - name: Upload RPM packages
        uses: actions/upload-artifact@v4
        with:
          name: rpm-packages-${{ steps.set-template.outputs.template }}
          path: build/tmp/deploy/rpm/**/*.rpm
          retention-days: 7
          if-no-files-found: warn

      - name: Upload QEMU image
        if: ${{ !inputs.skip_qemu }}
        uses: actions/upload-artifact@v4
        with:
          name: iotedge-qemu-image-${{ steps.set-template.outputs.template }}
          path: |
            build/tmp/deploy/images/qemux86-64/iotedge-qemu-image-qemux86-64.rootfs.ext4
            build/tmp/deploy/images/qemux86-64/bzImage
          retention-days: 7
          if-no-files-found: warn

      # Compress and save caches (only on push to main/kirkstone)
      - name: Compress caches
        if: always() && github.event_name == 'push'
        run: |
          if [[ -d "${YOCTO_CACHE_DIR}/sstate-cache" ]]; then
            echo "Compressing sstate cache..."
            tar -I 'zstd -T0 -19' -cf sstate-cache.tar.zst -C "${YOCTO_CACHE_DIR}" sstate-cache
            echo "Compressed sstate size: $(du -sh sstate-cache.tar.zst | cut -f1)"
          fi
          if [[ -d "${YOCTO_CACHE_DIR}/downloads" ]]; then
            echo "Compressing downloads cache..."
            tar -I 'zstd -T0 -19' -cf downloads.tar.zst -C "${YOCTO_CACHE_DIR}" downloads
            echo "Compressed downloads size: $(du -sh downloads.tar.zst | cut -f1)"
          fi

      - name: Save sstate cache
        uses: actions/cache/save@v4
        if: always() && github.event_name == 'push'
        with:
          path: sstate-cache.tar.zst
          key: yocto-sstate-${{ steps.set-template.outputs.template }}-${{ hashFiles('conf/templates/*/local.conf.sample', 'conf/templates/*/bblayers.conf.sample') }}

      - name: Save downloads cache
        uses: actions/cache/save@v4
        if: always() && github.event_name == 'push'
        with:
          path: downloads.tar.zst
          key: yocto-downloads-${{ hashFiles('recipes-*/**/*.bb', 'recipes-*/**/*.inc') }}

  # Auto-retry on timeout
  retry-on-timeout:
    name: Queue retry on timeout
    needs: build
    if: always() && needs.build.result == 'cancelled'
    runs-on: ubuntu-22.04
    permissions:
      actions: write
    steps:
      - name: Trigger retry workflow
        uses: actions/github-script@v7
        with:
          script: |
            const retryWorkflow = '${{ inputs.retry_workflow || 'ci-build.yml' }}';
            const ref = '${{ inputs.ref }}' || context.ref;
            
            if (context.eventName === 'pull_request') {
              console.log('Skipping retry for pull_request event');
              return;
            }
            
            const refName = ref.replace(/^refs\/(heads|tags)\//, '');
            
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: retryWorkflow,
              per_page: 10
            });
            
            const recentFailures = runs.data.workflow_runs.filter(run => 
              (run.conclusion === 'cancelled' || run.conclusion === 'timed_out' || run.conclusion === 'failure') &&
              run.head_branch === refName
            ).slice(0, 3);
            
            if (recentFailures.length >= 3) {
              console.log(`Too many recent failures for ${refName}, not retrying`);
              return;
            }
            
            console.log(`Triggering retry of ${retryWorkflow} for ref: ${refName}`);
            
            const inputs = retryWorkflow === 'release.yml' 
              ? { tag: refName }
              : {};
            
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: retryWorkflow,
              ref: refName.match(/^\d+\./) ? `refs/tags/${refName}` : `refs/heads/${refName}`,
              inputs: inputs
            });
