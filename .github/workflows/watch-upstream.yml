name: Watch upstream releases

on:
  schedule:
    # Run daily at 6:00 UTC
    - cron: "0 6 * * *"
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  check-upstream:
    name: Check for new releases
    runs-on: ubuntu-22.04
    outputs:
      release_version: ${{ steps.check.outputs.release_version }}  # Latest overall release (e.g., 1.5.35)
      daemon_version: ${{ steps.check.outputs.daemon_version }}    # Daemon binary version (e.g., 1.5.21)
      current_iotedge: ${{ steps.check.outputs.current_iotedge }}  # Current recipe version
      iotedge_update: ${{ steps.check.outputs.iotedge_update }}
      iotedge_version: ${{ steps.check.outputs.iotedge_version }}  # Version to update to
      iotedge_sha: ${{ steps.check.outputs.iotedge_sha }}
      iis_update: ${{ steps.check.outputs.iis_update }}
      iis_version: ${{ steps.check.outputs.iis_version }}
      iis_sha: ${{ steps.check.outputs.iis_sha }}
      latest_iis_version: ${{ steps.check.outputs.latest_iis_version }}
      needs_update: ${{ steps.check.outputs.needs_update }}
      is_significant: ${{ steps.check.outputs.is_significant }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check upstream releases
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Detect current versions from recipe files
            function getRecipeVersion(recipeDir, prefix) {
              try {
                const files = fs.readdirSync(recipeDir).filter(f => f.startsWith(prefix + '_') && f.endsWith('.bb'));
                if (files.length === 0) return null;
                const versions = files.map(f => f.replace(prefix + '_', '').replace('.bb', ''));
                versions.sort((a, b) => {
                  const [aMaj, aMin, aPatch] = a.split('.').map(Number);
                  const [bMaj, bMin, bPatch] = b.split('.').map(Number);
                  return (bMaj - aMaj) || (bMin - aMin) || (bPatch - aPatch);
                });
                return versions[0];
              } catch { return null; }
            }
            
            const currentIotedge = getRecipeVersion('recipes-core/iotedge', 'iotedge');
            const currentIis = getRecipeVersion('recipes-core/aziotd', 'aziotd');
            
            console.log(`ðŸ“‹ Current versions from recipes:`);
            console.log(`   IoT Edge: ${currentIotedge || 'not found'}`);
            console.log(`   IoT Identity Service: ${currentIis || 'not found'}`);
            
            // Use Azure/azure-iotedge as the canonical source (combined releases)
            // This tells us which IIS version goes with each Edge release
            const releases = await github.rest.repos.listReleases({
              owner: 'Azure',
              repo: 'azure-iotedge',
              per_page: 20
            });
            
            // Find latest stable 1.5.x release
            const stableReleases = releases.data.filter(r => 
              !r.prerelease && !r.draft && r.tag_name.match(/^1\.5\.\d+$/)
            );
            
            if (stableReleases.length === 0) {
              console.log('No stable 1.5.x release found');
              core.setOutput('needs_update', false);
              return;
            }
            
            const latestRelease = stableReleases[0];
            const releaseVersion = latestRelease.tag_name;
            console.log(`ðŸ” Latest release: ${releaseVersion}`);
            
            // Find daemon and IIS versions from release assets
            // Docker-only releases don't have package assets, so we search through releases
            // to find the most recent one with actual packages
            let daemonVersion = null;
            let iisVersion = null;
            let packageRelease = null;
            
            for (const release of stableReleases) {
              const edgeAsset = release.assets.find(a => a.name.match(/^aziot-edge-[\d.]+-.*\.rpm$/));
              const iisAsset = release.assets.find(a => a.name.match(/^aziot-identity-service-[\d.]+-.*\.rpm$/));
              
              if (edgeAsset && iisAsset) {
                packageRelease = release.tag_name;
                daemonVersion = edgeAsset.name.match(/aziot-edge-([\d.]+)-/)?.[1];
                iisVersion = iisAsset.name.match(/aziot-identity-service-([\d.]+)-/)?.[1];
                break;
              }
            }
            
            if (!daemonVersion || !iisVersion) {
              console.log('Could not find release with package assets');
              core.setOutput('needs_update', false);
              return;
            }
            
            console.log(`   Release version: ${releaseVersion}`);
            console.log(`   Package release: ${packageRelease}`);
            console.log(`   Daemon (aziot-edge) version: ${daemonVersion}`);
            console.log(`   IIS (aziot-identity-service) version: ${iisVersion}`);
            
            // Output versions for release notes and other jobs
            core.setOutput('release_version', releaseVersion);
            core.setOutput('daemon_version', daemonVersion);
            core.setOutput('latest_iis_version', iisVersion || currentIis);
            
            // Determine update type:
            // - Recipe behind daemon version â†’ significant update (new daemon code)
            // - Recipe at daemon version but behind release â†’ Docker-only (just notify)
            // - Recipe at release version â†’ already up to date
            
            const compareVersions = (a, b) => {
              const [aMaj, aMin, aPatch] = a.split('.').map(Number);
              const [bMaj, bMin, bPatch] = b.split('.').map(Number);
              return (aMaj - bMaj) || (aMin - bMin) || (aPatch - bPatch);
            };
            
            let needsUpdate = false;
            let isSignificant = false;
            let iotedgeUpdate = false;
            let iisUpdate = false;
            
            // Check IoT Edge: compare against daemon version for significance
            if (currentIotedge && compareVersions(currentIotedge, daemonVersion) < 0) {
              // Recipe is behind daemon version â†’ significant update needed
              iotedgeUpdate = true;
              needsUpdate = true;
              isSignificant = true;
              console.log(`   âš ï¸ IoT Edge significant update: ${currentIotedge} â†’ ${releaseVersion} (daemon: ${daemonVersion})`);
              
              // Get SHA from the release version tag (use latest release, not daemon version)
              const tagRef = await github.rest.git.getRef({
                owner: 'Azure', repo: 'iotedge',
                ref: `tags/${releaseVersion}`
              });
              core.setOutput('iotedge_version', releaseVersion);
              core.setOutput('iotedge_sha', tagRef.data.object.sha);
            } else if (currentIotedge && compareVersions(currentIotedge, releaseVersion) < 0) {
              // Recipe at daemon version but behind release â†’ Docker-only
              console.log(`   â„¹ï¸ IoT Edge Docker-only update available: ${currentIotedge} â†’ ${releaseVersion} (daemon unchanged at ${daemonVersion})`);
              // Don't set needsUpdate - will be handled by notify-docker-only job
            }
            
            // Check IIS: straightforward comparison
            if (iisVersion && currentIis && compareVersions(currentIis, iisVersion) < 0) {
              iisUpdate = true;
              needsUpdate = true;
              isSignificant = true;
              console.log(`   âš ï¸ IIS update needed: ${currentIis} â†’ ${iisVersion}`);
              
              const tagRef = await github.rest.git.getRef({
                owner: 'Azure', repo: 'iot-identity-service',
                ref: `tags/${iisVersion}`
              });
              core.setOutput('iis_version', iisVersion);
              core.setOutput('iis_sha', tagRef.data.object.sha);
            }
            
            core.setOutput('iotedge_update', iotedgeUpdate);
            core.setOutput('iis_update', iisUpdate);
            core.setOutput('needs_update', needsUpdate);
            core.setOutput('is_significant', isSignificant);
            core.setOutput('current_iotedge', currentIotedge);
            
            if (!needsUpdate && currentIotedge === releaseVersion) {
              console.log('âœ… Already at latest versions');
            }

  update-recipes:
    name: Update recipes
    needs: check-upstream
    if: needs.check-upstream.outputs.needs_update == 'true' && needs.check-upstream.outputs.is_significant == 'true'
    runs-on: ubuntu-22.04
    timeout-minutes: 60
    container:
      image: ghcr.io/${{ github.repository_owner }}/meta-iotedge-devcontainer:scarthgap
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      options: --user root
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fix git permissions
        run: git config --global --add safe.directory "${GITHUB_WORKSPACE}"

      - name: Update recipes
        env:
          IOTEDGE_UPDATE: ${{ needs.check-upstream.outputs.iotedge_update }}
          IOTEDGE_VERSION: ${{ needs.check-upstream.outputs.iotedge_version }}
          IOTEDGE_SHA: ${{ needs.check-upstream.outputs.iotedge_sha }}
          IIS_UPDATE: ${{ needs.check-upstream.outputs.iis_update }}
          IIS_VERSION: ${{ needs.check-upstream.outputs.iis_version }}
          IIS_SHA: ${{ needs.check-upstream.outputs.iis_sha }}
        run: |
          set -euo pipefail
          args=()
          
          # Only clean up recipes for components being updated
          if [[ "${IOTEDGE_UPDATE}" == "true" ]]; then
            echo "Cleaning up old IoT Edge recipes..."
            # iotedge and aziot-edged are both IoT Edge components
            for dir in iotedge aziot-edged; do
              find "recipes-core/${dir}" -name "*_*.bb" -type f -delete 2>/dev/null || true
              find "recipes-core/${dir}" -name "*-[0-9]*.inc" -type f -delete 2>/dev/null || true
            done
            echo "Updating IoT Edge to ${IOTEDGE_VERSION} (${IOTEDGE_SHA})"
            args+=(--iotedge-rev "${IOTEDGE_SHA}" --iotedge-version "${IOTEDGE_VERSION}")
          fi
          
          if [[ "${IIS_UPDATE}" == "true" ]]; then
            echo "Cleaning up old IIS recipes..."
            # aziotd, aziotctl, aziot-keys are IIS components
            for dir in aziotd aziotctl aziot-keys; do
              find "recipes-core/${dir}" -name "*_*.bb" -type f -delete 2>/dev/null || true
              find "recipes-core/${dir}" -name "*-[0-9]*.inc" -type f -delete 2>/dev/null || true
            done
            echo "Updating IIS to ${IIS_VERSION} (${IIS_SHA})"
            args+=(--iis-rev "${IIS_SHA}" --iis-version "${IIS_VERSION}")
          fi
          
          echo "Remaining recipe files before update:"
          find recipes-core -name "*.bb" -o -name "*.inc" | grep -v files/ | sort || true
          
          if [[ ${#args[@]} -gt 0 ]]; then
            ./scripts/update-recipes.sh "${args[@]}"
          fi
          
          echo "Recipe files after update:"
          find recipes-core -name "*.bb" -o -name "*.inc" | grep -v files/ | sort

      - name: Create pull request
        uses: peter-evans/create-pull-request@v6
        with:
          title: "Update to IoT Edge ${{ needs.check-upstream.outputs.iotedge_version }}"
          commit-message: |
            Update IoT Edge recipes for ${{ needs.check-upstream.outputs.iotedge_version }}
            
            - IoT Edge daemon: ${{ needs.check-upstream.outputs.iotedge_version || 'unchanged' }}
            - IoT Identity Service: ${{ needs.check-upstream.outputs.iis_version || 'unchanged' }}
          branch: automation/upstream-update
          delete-branch: true
          labels: |
            automated
            upstream-update
          body: |
            ## Automated Upstream Update
            
            This PR was automatically created by the upstream release watcher.
            
            ### Versions
            | Component | Current | New |
            |-----------|---------|-----|
            | IoT Edge | ${{ env.CURRENT_IOTEDGE }} | ${{ needs.check-upstream.outputs.iotedge_version }} |
            | IoT Identity Service | ${{ env.CURRENT_IIS }} | ${{ needs.check-upstream.outputs.iis_version || env.CURRENT_IIS }} |
            
            ### Validation Checklist
            - [ ] CI build passes
            - [ ] QEMU validation passes
            
            ### After Merging
            Create a release by running:
            ```bash
            git pull origin main
            git tag ${{ needs.check-upstream.outputs.release_version }}
            git push origin ${{ needs.check-upstream.outputs.release_version }}
            ```
            This will trigger the [release workflow](../actions/workflows/release.yml) to build and publish packages.
            
            ### Release Notes
            - [Azure IoT Edge ${{ needs.check-upstream.outputs.release_version }}](https://github.com/Azure/azure-iotedge/releases/tag/${{ needs.check-upstream.outputs.release_version }})

  # Notify when recipes are current (daemon + IIS) but there's a newer Docker-only release
  notify-docker-only:
    name: Notify Docker-only update
    needs: check-upstream
    # Notify if: no significant update (daemon or IIS) AND recipe is behind release version
    # This means only Docker images changed, not the daemon or IIS binaries
    if: |
      needs.check-upstream.outputs.is_significant != 'true' &&
      needs.check-upstream.outputs.current_iotedge != needs.check-upstream.outputs.release_version
    runs-on: ubuntu-22.04
    permissions:
      issues: write
    steps:
      - name: Create issue for Docker-only update
        uses: actions/github-script@v7
        with:
          script: |
            const releaseVersion = '${{ needs.check-upstream.outputs.release_version }}';
            const daemonVersion = '${{ needs.check-upstream.outputs.daemon_version }}';
            const currentVersion = '${{ needs.check-upstream.outputs.current_iotedge }}';
            
            // Check if there's already an open issue for this release
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'docker-only-update'
            });
            
            const existingIssue = issues.data.find(i => i.title.includes(releaseVersion));
            if (existingIssue) {
              console.log(`Issue already exists for ${releaseVersion}`);
              return;
            }
            
            const body = [
              'A new IoT Edge release is available, but it only contains Docker image updates.',
              '',
              `**Latest Release:** ${releaseVersion}`,
              `**Daemon Version:** ${daemonVersion} (unchanged)`,
              `**Current Recipe:** ${currentVersion}`,
              '',
              'No recipe updates are needed since the daemon binaries haven\'t changed.',
              '',
              'However, you may want to create a new release tag to stay in sync with upstream version numbers:',
              '',
              '```bash',
              `git tag ${releaseVersion}`,
              `git push origin ${releaseVersion}`,
              '```',
              '',
              'This issue is for tracking purposes only. Close it once acknowledged.',
              '',
              `[View release notes](https://github.com/Azure/azure-iotedge/releases/tag/${releaseVersion})`
            ].join('\n');
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `IoT Edge ${releaseVersion} released (Docker images only)`,
              labels: ['docker-only-update', 'no-action-needed'],
              body: body
            });
