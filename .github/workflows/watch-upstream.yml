name: Watch upstream releases

on:
  schedule:
    # Run daily at 6:00 UTC
    - cron: "0 6 * * *"
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  check-upstream:
    name: Check for new releases
    runs-on: ubuntu-22.04
    outputs:
      release_version: ${{ steps.check.outputs.release_version }}  # Latest overall release (e.g., 1.5.35)
      iotedge_update: ${{ steps.check.outputs.iotedge_update }}
      iotedge_version: ${{ steps.check.outputs.iotedge_version }}  # Daemon version (e.g., 1.5.21)
      iotedge_sha: ${{ steps.check.outputs.iotedge_sha }}
      iis_update: ${{ steps.check.outputs.iis_update }}
      iis_version: ${{ steps.check.outputs.iis_version }}
      iis_sha: ${{ steps.check.outputs.iis_sha }}
      latest_iis_version: ${{ steps.check.outputs.latest_iis_version }}
      needs_update: ${{ steps.check.outputs.needs_update }}
      is_significant: ${{ steps.check.outputs.is_significant }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check upstream releases
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Detect current versions from recipe files
            function getRecipeVersion(recipeDir, prefix) {
              try {
                const files = fs.readdirSync(recipeDir).filter(f => f.startsWith(prefix + '_') && f.endsWith('.bb'));
                if (files.length === 0) return null;
                const versions = files.map(f => f.replace(prefix + '_', '').replace('.bb', ''));
                versions.sort((a, b) => {
                  const [aMaj, aMin, aPatch] = a.split('.').map(Number);
                  const [bMaj, bMin, bPatch] = b.split('.').map(Number);
                  return (bMaj - aMaj) || (bMin - aMin) || (bPatch - aPatch);
                });
                return versions[0];
              } catch { return null; }
            }
            
            const currentIotedge = getRecipeVersion('recipes-core/iotedge', 'iotedge');
            const currentIis = getRecipeVersion('recipes-core/aziotd', 'aziotd');
            
            console.log(`ðŸ“‹ Current versions from recipes:`);
            console.log(`   IoT Edge: ${currentIotedge || 'not found'}`);
            console.log(`   IoT Identity Service: ${currentIis || 'not found'}`);
            
            // Use Azure/azure-iotedge as the canonical source (combined releases)
            // This repo tells us which versions go together and if it's a significant update
            const releases = await github.rest.repos.listReleases({
              owner: 'Azure',
              repo: 'azure-iotedge',
              per_page: 20
            });
            
            // Find the latest significant 1.5.x release (has daemon changes, not just Docker images)
            let latestSignificant = null;
            let latestEdgeVersion = null;
            let latestIisVersion = null;
            let latestReleaseVersion = null;  // The overall latest release tag (e.g., 1.5.35)
            
            for (const release of releases.data) {
              if (release.prerelease || release.draft) continue;
              if (!release.tag_name.match(/^1\.5\.\d+$/)) continue;
              
              // Track the latest overall release version (first non-prerelease 1.5.x we see)
              if (!latestReleaseVersion) {
                latestReleaseVersion = release.tag_name;
              }
              
              const body = release.body || '';
              
              // Docker-only releases say "daemon remains at version X"
              const isDaemonUpdate = body.includes('## aziot-edge') || 
                                     body.includes('## aziot-identity-service');
              const isDockerOnly = body.toLowerCase().includes('daemon remains at version');
              
              // Extract versions from release assets (most reliable)
              // Asset names like: aziot-edge-1.5.21-1.el8.x86_64.rpm, aziot-identity-service-1.5.6-1.el8.x86_64.rpm
              const edgeAsset = release.assets.find(a => a.name.match(/^aziot-edge-[\d.]+-.*\.rpm$/));
              const iisAsset = release.assets.find(a => a.name.match(/^aziot-identity-service-[\d.]+-.*\.rpm$/));
              
              const edgeVer = edgeAsset ? edgeAsset.name.match(/aziot-edge-([\d.]+)-/)?.[1] : null;
              const iisVer = iisAsset ? iisAsset.name.match(/aziot-identity-service-([\d.]+)-/)?.[1] : null;
              
              console.log(`ðŸ” Release ${release.tag_name}: edge=${edgeVer}, iis=${iisVer}, significant=${isDaemonUpdate && !isDockerOnly}`);
              
              // Track latest IIS version we've seen
              if (iisVer && !latestIisVersion) {
                latestIisVersion = iisVer;
              }
              
              // Track latest edge version (even Docker-only releases bump this)
              if (edgeVer && !latestEdgeVersion) {
                latestEdgeVersion = edgeVer;
              }
              
              // Find the most recent significant update
              if (!latestSignificant && isDaemonUpdate && !isDockerOnly && edgeVer && iisVer) {
                latestSignificant = { release, edgeVersion: edgeVer, iisVersion: iisVer };
              }
            }
            
            // Always output latest IIS version for release notes links
            core.setOutput('latest_iis_version', latestIisVersion || currentIis);
            // Output the latest overall release version for tagging
            core.setOutput('release_version', latestReleaseVersion);
            
            console.log(`\nðŸ“¦ Latest overall release: ${latestReleaseVersion}`);
            
            if (!latestSignificant) {
              console.log('No significant updates found');
              core.setOutput('needs_update', false);
              core.setOutput('is_significant', false);
              return;
            }
            
            const { release, edgeVersion, iisVersion } = latestSignificant;
            console.log(`âœ¨ Latest significant release: ${release.tag_name} (daemon code)`);
            console.log(`   IoT Edge daemon: ${edgeVersion}`);
            console.log(`   IoT Identity Service: ${iisVersion}`);
            
            let needsUpdate = false;
            let iotedgeUpdate = false;
            let iisUpdate = false;
            
            // Check if we need IoT Edge update
            if (edgeVersion !== currentIotedge) {
              iotedgeUpdate = true;
              needsUpdate = true;
              console.log(`   âš ï¸ IoT Edge update needed: ${currentIotedge} â†’ ${edgeVersion}`);
              
              // Get commit SHA from Azure/iotedge repo
              const tagRef = await github.rest.git.getRef({
                owner: 'Azure', repo: 'iotedge',
                ref: `tags/${edgeVersion}`
              });
              core.setOutput('iotedge_version', edgeVersion);
              core.setOutput('iotedge_sha', tagRef.data.object.sha);
            }
            
            // Check if we need IIS update  
            if (iisVersion !== currentIis) {
              iisUpdate = true;
              needsUpdate = true;
              console.log(`   âš ï¸ IIS update needed: ${currentIis} â†’ ${iisVersion}`);
              
              // Get commit SHA from Azure/iot-identity-service repo
              const tagRef = await github.rest.git.getRef({
                owner: 'Azure', repo: 'iot-identity-service',
                ref: `tags/${iisVersion}`
              });
              core.setOutput('iis_version', iisVersion);
              core.setOutput('iis_sha', tagRef.data.object.sha);
            }
            
            core.setOutput('iotedge_update', iotedgeUpdate);
            core.setOutput('iis_update', iisUpdate);
            core.setOutput('needs_update', needsUpdate);
            core.setOutput('is_significant', true);
            
            if (!needsUpdate) {
              console.log('âœ… Already at latest significant versions');
            }

  update-recipes:
    name: Update recipes
    needs: check-upstream
    if: needs.check-upstream.outputs.needs_update == 'true' && needs.check-upstream.outputs.is_significant == 'true'
    runs-on: ubuntu-22.04
    timeout-minutes: 60
    container:
      image: ghcr.io/${{ github.repository_owner }}/meta-iotedge-devcontainer:scarthgap
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      options: --user root
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fix git permissions
        run: git config --global --add safe.directory "${GITHUB_WORKSPACE}"

      - name: Update recipes
        env:
          IOTEDGE_UPDATE: ${{ needs.check-upstream.outputs.iotedge_update }}
          RELEASE_VERSION: ${{ needs.check-upstream.outputs.release_version }}
          IOTEDGE_SHA: ${{ needs.check-upstream.outputs.iotedge_sha }}
          IIS_UPDATE: ${{ needs.check-upstream.outputs.iis_update }}
          IIS_VERSION: ${{ needs.check-upstream.outputs.iis_version }}
          IIS_SHA: ${{ needs.check-upstream.outputs.iis_sha }}
        run: |
          set -euo pipefail
          args=()
          
          # Only clean up recipes for components being updated
          if [[ "${IOTEDGE_UPDATE}" == "true" ]]; then
            echo "Cleaning up old IoT Edge recipes..."
            # iotedge and aziot-edged are both IoT Edge components
            for dir in iotedge aziot-edged; do
              find "recipes-core/${dir}" -name "*_*.bb" -type f -delete 2>/dev/null || true
              find "recipes-core/${dir}" -name "*-[0-9]*.inc" -type f -delete 2>/dev/null || true
            done
            # Use release version for package name, but daemon SHA for source code
            echo "Updating IoT Edge to ${RELEASE_VERSION} (source from ${IOTEDGE_SHA})"
            args+=(--iotedge-rev "${IOTEDGE_SHA}" --iotedge-version "${RELEASE_VERSION}")
          fi
          
          if [[ "${IIS_UPDATE}" == "true" ]]; then
            echo "Cleaning up old IIS recipes..."
            # aziotd, aziotctl, aziot-keys are IIS components
            for dir in aziotd aziotctl aziot-keys; do
              find "recipes-core/${dir}" -name "*_*.bb" -type f -delete 2>/dev/null || true
              find "recipes-core/${dir}" -name "*-[0-9]*.inc" -type f -delete 2>/dev/null || true
            done
            echo "Updating IIS to ${IIS_VERSION} (${IIS_SHA})"
            args+=(--iis-rev "${IIS_SHA}" --iis-version "${IIS_VERSION}")
          fi
          
          echo "Remaining recipe files before update:"
          find recipes-core -name "*.bb" -o -name "*.inc" | grep -v files/ | sort || true
          
          if [[ ${#args[@]} -gt 0 ]]; then
            ./scripts/update-recipes.sh "${args[@]}"
          fi
          
          echo "Recipe files after update:"
          find recipes-core -name "*.bb" -o -name "*.inc" | grep -v files/ | sort

      - name: Create pull request
        uses: peter-evans/create-pull-request@v6
        with:
          title: "Update to IoT Edge ${{ needs.check-upstream.outputs.release_version }}"
          commit-message: |
            Update IoT Edge recipes for ${{ needs.check-upstream.outputs.release_version }}
            
            - IoT Edge daemon: ${{ needs.check-upstream.outputs.iotedge_version || 'unchanged' }}
            - IoT Identity Service: ${{ needs.check-upstream.outputs.iis_version || 'unchanged' }}
          branch: automation/upstream-update
          delete-branch: true
          labels: |
            automated
            upstream-update
          body: |
            ## Automated Upstream Update
            
            This PR was automatically created by the upstream release watcher.
            
            ### Versions
            | Component | Target | Source Code From |
            |-----------|--------|------------------|
            | **Package Version** | **${{ needs.check-upstream.outputs.release_version }}** | - |
            | IoT Edge daemon | ${{ needs.check-upstream.outputs.release_version }} | ${{ needs.check-upstream.outputs.iotedge_version }} |
            | IoT Identity Service | ${{ needs.check-upstream.outputs.iis_version }} | ${{ needs.check-upstream.outputs.iis_version }} |
            
            > **Note:** Package version matches Azure's latest release (${{ needs.check-upstream.outputs.release_version }}). The daemon source code comes from ${{ needs.check-upstream.outputs.iotedge_version }} (last significant update with daemon changes).
            
            ### Validation Checklist
            - [ ] CI build passes
            - [ ] QEMU validation passes
            
            ### After Merging
            Create a release by running:
            ```bash
            git pull origin main
            git tag ${{ needs.check-upstream.outputs.release_version }}
            git push origin ${{ needs.check-upstream.outputs.release_version }}
            ```
            This will trigger the [release workflow](../actions/workflows/release.yml) to build and publish packages.
            
            ### Release Notes
            - [Azure IoT Edge ${{ needs.check-upstream.outputs.release_version }}](https://github.com/Azure/azure-iotedge/releases/tag/${{ needs.check-upstream.outputs.release_version }})

  # Notify when recipes are current but there's a newer Docker-only release
  notify-docker-only:
    name: Notify Docker-only update
    needs: check-upstream
    # Only notify if: recipes are up-to-date AND there's a newer release (Docker-only)
    if: |
      needs.check-upstream.outputs.needs_update == 'false' &&
      needs.check-upstream.outputs.release_version != needs.check-upstream.outputs.iotedge_version
    runs-on: ubuntu-22.04
    steps:
      - name: Create issue for Docker-only update
        uses: actions/github-script@v7
        with:
          script: |
            const releaseVersion = '${{ needs.check-upstream.outputs.release_version }}';
            const daemonVersion = '${{ needs.check-upstream.outputs.iotedge_version }}';
            
            // Check if there's already an open issue for this release
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'docker-only-update'
            });
            
            const existingIssue = issues.data.find(i => i.title.includes(releaseVersion));
            if (existingIssue) {
              console.log(`Issue already exists for ${releaseVersion}`);
              return;
            }
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `IoT Edge ${releaseVersion} released (Docker images only)`,
              labels: ['docker-only-update', 'no-action-needed'],
              body: [
                'A new IoT Edge release is available, but it only contains Docker image updates.',
                '',
                `**Latest Release:** ${releaseVersion}`,
                `**Daemon Version:** ${daemonVersion} (unchanged)`,
                '',
                'No recipe updates are needed since the daemon binaries haven\'t changed.',
                '',
                'However, you may want to create a new release tag to stay in sync with upstream:',
                '',
                '```bash',
                `git tag ${releaseVersion}`,
                `git push origin ${releaseVersion}`,
                '```',
                '',
                'This issue is for tracking purposes only. Close it once acknowledged.',
                '',
                `[View release notes](https://github.com/Azure/azure-iotedge/releases/tag/${releaseVersion})`
              ].join('\n')
            });
