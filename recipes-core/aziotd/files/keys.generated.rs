/* automatically generated by rust-bindgen */

pub const AZIOT_KEYS_RC_OK: u32 = 0;
pub const AZIOT_KEYS_RC_ERR_INVALID_PARAMETER: u32 = 1;
pub const AZIOT_KEYS_RC_ERR_EXTERNAL: u32 = 2;
pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_ALGORITHM: u32 = 1;
pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_EC_CURVE_OID: u32 = 2;
pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_EC_POINT: u32 = 3;
pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_RSA_MODULUS: u32 = 4;
pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_RSA_EXPONENT: u32 = 5;
pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_ALGORITHM_EC: u32 = 1;
pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_ALGORITHM_RSA: u32 = 2;
pub const AZIOT_KEYS_KEY_USAGE_DERIVE: u32 = 1;
pub const AZIOT_KEYS_KEY_USAGE_ENCRYPT: u32 = 16;
pub const AZIOT_KEYS_KEY_USAGE_SIGN: u32 = 1;
pub const AZIOT_KEYS_SIGN_MECHANISM_ECDSA: u32 = 1;
pub const AZIOT_KEYS_SIGN_MECHANISM_HMAC_SHA256: u32 = 2;
pub const AZIOT_KEYS_SIGN_MECHANISM_DERIVED: u32 = 3;
pub const AZIOT_KEYS_ENCRYPT_MECHANISM_AEAD: u32 = 1;
pub const AZIOT_KEYS_ENCRYPT_MECHANISM_RSA_PKCS1: u32 = 2;
pub const AZIOT_KEYS_ENCRYPT_MECHANISM_RSA_NO_PADDING: u32 = 3;
pub const AZIOT_KEYS_ENCRYPT_MECHANISM_DERIVED: u32 = 4;
pub const AZIOT_KEYS_VERSION_2_0_0_0: u32 = 33554432;
pub const AZIOT_KEYS_VERSION_2_1_0_0: u32 = 33619968;
#[doc = " Return code of a function. This is a transparent wrapper around a `std::os::raw::c_uint` (`unsigned int`)."]
#[doc = ""]
#[doc = " One of the `AZIOT_KEYS_RC_ERR_*` constants."]
pub type AZIOT_KEYS_RC = ::std::os::raw::c_uint;
#[doc = " Represents the version of the API exported by this library."]
pub type AZIOT_KEYS_VERSION = ::std::os::raw::c_uint;
#[doc = " The base struct of all of function lists."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AZIOT_KEYS_FUNCTION_LIST {
    #[doc = " The version of the API represented in this function list."]
    #[doc = ""]
    #[doc = " The specific subtype of `AZIOT_KEYS_FUNCTION_LIST` can be determined by inspecting this value."]
    pub version: AZIOT_KEYS_VERSION,
}
#[test]
fn bindgen_test_layout_AZIOT_KEYS_FUNCTION_LIST() {
    assert_eq!(
        ::std::mem::size_of::<AZIOT_KEYS_FUNCTION_LIST>(),
        4usize,
        concat!("Size of: ", stringify!(AZIOT_KEYS_FUNCTION_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<AZIOT_KEYS_FUNCTION_LIST>(),
        4usize,
        concat!("Alignment of ", stringify!(AZIOT_KEYS_FUNCTION_LIST))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST),
            "::",
            stringify!(version)
        )
    );
}
#[doc = " The mechanism used with `sign` / `verify`."]
#[doc = ""]
#[doc = " One of the `AZIOT_KEYS_SIGN_MECHANISM_*` constants."]
pub type AZIOT_KEYS_SIGN_MECHANISM = ::std::os::raw::c_uint;
#[doc = " Used with `sign` / `verify` with the [`AZIOT_KEYS_SIGN_MECHANISM_DERIVED`] mechanism."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AZIOT_KEYS_SIGN_DERIVED_PARAMETERS {
    #[doc = " The data used to derive the new key."]
    pub derivation_data: *const ::std::os::raw::c_uchar,
    #[doc = " The length of the `derivation_data` buffer."]
    pub derivation_data_len: usize,
    #[doc = " The signature mechanism to use with the derived key."]
    #[doc = ""]
    #[doc = " One of the `AZIOT_KEYS_SIGN_MECHANISM_*` constants."]
    pub mechanism: AZIOT_KEYS_SIGN_MECHANISM,
    #[doc = " The parameters of the signature mechanism specified by `mechanism`."]
    pub parameters: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AZIOT_KEYS_SIGN_DERIVED_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>(),
        32usize,
        concat!("Size of: ", stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>())).derivation_data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS),
            "::",
            stringify!(derivation_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>())).derivation_data_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS),
            "::",
            stringify!(derivation_data_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>())).mechanism as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS),
            "::",
            stringify!(mechanism)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>())).parameters as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS),
            "::",
            stringify!(parameters)
        )
    );
}
#[doc = " Used with `encrypt` / `decrypt` with the [`AZIOT_KEYS_ENCRYPT_MECHANISM_AEAD`] mechanism."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS {
    #[doc = " The IV."]
    pub iv: *const ::std::os::raw::c_uchar,
    #[doc = " The length of the `iv` buffer."]
    pub iv_len: usize,
    #[doc = " The AAD."]
    pub aad: *const ::std::os::raw::c_uchar,
    #[doc = " The length of the `aad` buffer."]
    pub aad_len: usize,
}
#[test]
fn bindgen_test_layout_AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>(),
        32usize,
        concat!("Size of: ", stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>())).iv as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>())).iv_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS),
            "::",
            stringify!(iv_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>())).aad as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS),
            "::",
            stringify!(aad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>())).aad_len as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS),
            "::",
            stringify!(aad_len)
        )
    );
}
#[doc = " The mechanism used with `encrypt` / `decrypt`."]
#[doc = ""]
#[doc = " One of the `AZIOT_KEYS_ENCRYPT_MECHANISM_*` constants."]
pub type AZIOT_KEYS_ENCRYPT_MECHANISM = ::std::os::raw::c_uint;
#[doc = " Used with `encrypt` / `decrypt` with the [`AZIOT_KEYS_ENCRYPT_MECHANISM_DERIVED`] mechanism."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS {
    #[doc = " The data used to derive the new key."]
    pub derivation_data: *const ::std::os::raw::c_uchar,
    #[doc = " The length of the `derivation_data` buffer."]
    pub derivation_data_len: usize,
    #[doc = " The encryption mechanism to use with the derived key."]
    #[doc = ""]
    #[doc = " One of the `AZIOT_KEYS_ENCRYPT_MECHANISM_*` constants."]
    pub mechanism: AZIOT_KEYS_ENCRYPT_MECHANISM,
    #[doc = " The parameters of the encryption mechanism specified by `mechanism`."]
    pub parameters: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>())).derivation_data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS),
            "::",
            stringify!(derivation_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>())).derivation_data_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS),
            "::",
            stringify!(derivation_data_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>())).mechanism as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS),
            "::",
            stringify!(mechanism)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>())).parameters as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS),
            "::",
            stringify!(parameters)
        )
    );
}
#[doc = " Used as the parameter type with `get_key_pair_parameter`."]
#[doc = ""]
#[doc = " One of the `AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_*` constants."]
pub type AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE = ::std::os::raw::c_uint;
#[doc = " The usage of key being created with `create_key_if_not_exists` or"]
#[doc = " being imported with `import_key`."]
#[doc = ""]
#[doc = " This is a bitflag type, so its values can be combined. But note that not all combinations of flags"]
#[doc = " are valid."]
pub type AZIOT_KEYS_KEY_USAGE = ::std::os::raw::c_uint;
#[doc = " The specific implementation of [`AZIOT_KEYS_FUNCTION_LIST`] for API version 2.0.0.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AZIOT_KEYS_FUNCTION_LIST_2_0_0_0 {
    #[doc = " The value of `base.version` must be [`AZIOT_KEYS_VERSION_2_0_0_0`]."]
    pub base: AZIOT_KEYS_FUNCTION_LIST,
    #[doc = " Set a parameter on this library."]
    #[doc = ""]
    #[doc = " `name` must not be `NULL`."]
    #[doc = " `value` may be `NULL`."]
    #[doc = ""]
    #[doc = " The caller may free the name string after this method returns. If the implementation needs to hold on to it, it must make a copy."]
    #[doc = ""]
    #[doc = " The interpretation of names and values depends on the implementation. A special case is for names that start with `preloaded_key:`,"]
    #[doc = " such as `preloaded_key:foo`. This defines a user-provided association of the key ID \"foo\" with the location specified by `value`."]
    #[doc = " Any call that uses the key with ID \"foo\" must use the location specified by `value`. Note that this does not mean the key already exists"]
    #[doc = " at that location; but it does mean that `create_key_if_not_exists` (for example) must create the key at that location and not any other."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `name` is `NULL`."]
    #[doc = "   - `name` is not recognized by this implementation, or invalid in some other way."]
    #[doc = "   - `value` is invalid."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub set_parameter: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Create or load a key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " - If a key pair with that ID exists and can be loaded, it will be left as-is."]
    #[doc = " - If a key pair with that ID does not exist, a new key will be created. It will be saved such that it can be looked up later using that same ID."]
    #[doc = ""]
    #[doc = " `preferred_algorithms` dictates the caller's preference for the key algorithm. It is a string with components separated by COLON U+003A `:`,"]
    #[doc = " where each component specifies the name of an algorithm and will be attempted by the implementation in that order."]
    #[doc = " The valid components are `\"ec-p256\"` for secp256r1, `\"rsa-2048\"` for 2048-bit RSA, `\"rsa-4096\"` for 4096-bit RSA, and `\"*\"` which indicates"]
    #[doc = " any algorithm of the implementation's choice. For example, the caller might use `\"ec-p256:rsa-2048:*\"` to indicate that it would like"]
    #[doc = " the implementation to use secp256r1, else RSA-2048 if that fails, else any other algorithm of the implementation's choice if that also fails."]
    #[doc = ""]
    #[doc = " If an implementation does not recognize a particular component as an algorithm, or is unable to use the algorithm to generate a key pair,"]
    #[doc = " it must ignore that component and try the next one. If no components are left, the implementation returns an error."]
    #[doc = " The implementation is allowed to be unable to generate a key pair regardless of which algorithms are specified; this is true even if"]
    #[doc = " the wildcard algorithm is specified."]
    #[doc = ""]
    #[doc = " If `preferred_algorithms` is `NULL`, it must be interpreted the same as if it was `\"*\"`."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - `preferred_algorithms` is invalid."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub create_key_pair_if_not_exists: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            preferred_algorithms: *const ::std::os::raw::c_char,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Load an existing key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " This validates that a key pair with the given ID exists and can be loaded."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub load_key_pair: ::std::option::Option<
        unsafe extern "C" fn(id: *const ::std::os::raw::c_char) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Get the value of a parameter of the key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " `type_` must be set to one of the `AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_*` constants."]
    #[doc = ""]
    #[doc = " `value` is an output byte buffer allocated by the caller to store the parameter value."]
    #[doc = " The caller sets `value_len` to the address of the length of the buffer."]
    #[doc = " The implementation populates `value` with the parameter value and sets `value_len` to the number of bytes it wrote to `value`."]
    #[doc = ""]
    #[doc = " It is allowed for the caller to call the function with `value` set to `NULL`. In this case the implementation calculates"]
    #[doc = " an upper bound for how many bytes will be needed to store the parameter value, sets that in `value_len` and returns."]
    #[doc = ""]
    #[doc = " The format of the data stored in `value` is determined by the `type_`. See the documentation of those constants for details."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key pair specified by `id` does not exist."]
    #[doc = "   - `type_` is not a valid parameter type for the key pair specified by `id`."]
    #[doc = "   - `value` is insufficiently large to hold the parameter value."]
    #[doc = "   - `value_len` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub get_key_pair_parameter: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            type_: AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE,
            value: *mut ::std::os::raw::c_uchar,
            value_len: *mut usize,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Create or load a key identified by the specified `id`."]
    #[doc = ""]
    #[doc = " - If a key with that ID exists and can be loaded, it will be left as-is."]
    #[doc = " - If a key with that ID does not exist, a new random key will be created."]
    #[doc = "   It will be saved such that it can be looked up later using that same ID."]
    #[doc = ""]
    #[doc = " `usage` specifies what the key will be used for."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub create_key_if_not_exists: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            usage: AZIOT_KEYS_KEY_USAGE,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Load an existing key identified by the specified `id`."]
    #[doc = ""]
    #[doc = " This validates that a key with the given ID exists and can be loaded."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key specified by `id` does not exist."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub load_key: ::std::option::Option<
        unsafe extern "C" fn(id: *const ::std::os::raw::c_char) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Import a symmetric key with the given `id`."]
    #[doc = ""]
    #[doc = " It will be saved such that it can be looked up later using that same ID."]
    #[doc = ""]
    #[doc = " If a key with that ID already exists, the existing key will be overwritten."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - `bytes` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub import_key: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            bytes: *const u8,
            bytes_len: usize,
            usage: AZIOT_KEYS_KEY_USAGE,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Derive a key with a given base key using some derivation data, and return the derived key."]
    #[doc = ""]
    #[doc = " The derivation process used by this function must be identical to"]
    #[doc = " the derivation process used by `encrypt` with the `AZIOT_KEYS_ENCRYPT_MECHANISM_DERIVED` mechanism and"]
    #[doc = " the derivation process used by `sign` with the `AZIOT_KEYS_SIGN_MECHANISM_DERIVED` mechanism."]
    #[doc = ""]
    #[doc = " `base_id` is the ID of the key that will be used to derive the new key. The key must have been created / imported"]
    #[doc = " with the [`crate::AZIOT_KEYS_KEY_USAGE_DERIVE`] usage."]
    #[doc = ""]
    #[doc = " `derivation_data` is a byte buffer containing the data that used for the derivation."]
    #[doc = " The caller sets `derivation_data_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `derived_key` is an output byte buffer allocated by the caller to store the derived key."]
    #[doc = " The caller sets `derived_key_len` to the address of the length of the buffer."]
    #[doc = " The implementation populates `derived_key` with the parameter derived_key and sets `derived_key_len` to the number of bytes it wrote to `derived_key`."]
    #[doc = ""]
    #[doc = " It is allowed for the caller to call the function with `derived_key` set to `NULL`. In this case the implementation calculates"]
    #[doc = " an upper bound for how many bytes will be needed to store the derived key, sets that in `derived_key_len` and returns."]
    #[doc = ""]
    #[doc = " The new key is not persisted by the implementation, only returned in `derived_key`."]
    #[doc = " If the caller wishes to persist it, they can import it with `import_key`."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `base_id` is `NULL`."]
    #[doc = "   - `base_id` is invalid."]
    #[doc = "   - The key specified by `base_id` does not exist."]
    #[doc = "   - `derivation_data` is `NULL`."]
    #[doc = "   - `derived_key` is insufficiently large to hold the parameter value."]
    #[doc = "   - `derived_key_len` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub derive_key: ::std::option::Option<
        unsafe extern "C" fn(
            base_id: *const ::std::os::raw::c_char,
            derivation_data: *const u8,
            derivation_data_len: usize,
            derived_key: *mut ::std::os::raw::c_uchar,
            derived_key_len: *mut usize,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Sign the given digest using the key or key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_SIGN_MECHANISM_*` constants."]
    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
    #[doc = ""]
    #[doc = " `digest` is a byte buffer containing the data that must be signed."]
    #[doc = " The caller sets `digest_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `signature` is an output byte buffer allocated by the caller to store the signature."]
    #[doc = " The caller sets `signature_len` to the address of the length of the buffer."]
    #[doc = " The implementation populates `signature` with the signature and sets `signature_len` to the number of bytes it wrote to `signature`."]
    #[doc = ""]
    #[doc = " It is allowed for the caller to call the function with `signature` set to `NULL`. In this case the implementation calculates"]
    #[doc = " an upper bound for how many bytes will be needed to store the signature, sets that in `signature_len` and returns."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key or key pair specified by `id` does not exist."]
    #[doc = "   - `mechanism` is not a valid signature mechanism for the key or key pair specified by `id`."]
    #[doc = "   - `parameters` is invalid."]
    #[doc = "   - `digest` is `NULL`."]
    #[doc = "   - `signature` is insufficiently large to hold the signature."]
    #[doc = "   - `signature_len` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub sign: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            mechanism: AZIOT_KEYS_SIGN_MECHANISM,
            parameters: *const ::std::os::raw::c_void,
            digest: *const ::std::os::raw::c_uchar,
            digest_len: usize,
            signature: *mut ::std::os::raw::c_uchar,
            signature_len: *mut usize,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Verify the signature of the given digest using the key or key pair (but see note below) identified by the specified `id`."]
    #[doc = ""]
    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_SIGN_MECHANISM_*` constants."]
    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
    #[doc = ""]
    #[doc = " `digest` is a byte buffer containing the data that must be signed."]
    #[doc = " The caller sets `digest_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `signature` is a byte buffer containing the signature that the caller expects the data to have."]
    #[doc = " The caller sets `signature_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `ok` is an output parameter that stores whether the signature could be verified or not."]
    #[doc = " If the function is able to compute the signature of the data, it sets `ok` and returns `AZIOT_KEYS_RC_OK`."]
    #[doc = " `ok` is set to 0 if the signature is invalid and non-zero if the signature is valid."]
    #[doc = " The value stored in `ok` is only meaningful if the function returns `AZIOT_KEYS_RC_OK`, otherwise it must be ignored."]
    #[doc = ""]
    #[doc = " Note: The implementation is not required to support verification with key pairs, ie `AZIOT_KEYS_SIGN_MECHANISM_ECDSA`."]
    #[doc = " The caller can do the verification themselves with the public parameters of the EC key as obtained via `get_key_pair_parameter`."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key or key pair specified by `id` does not exist."]
    #[doc = "   - `mechanism` is not a valid signature mechanism for the key or key pair specified by `id`."]
    #[doc = "   - `parameters` is invalid."]
    #[doc = "   - `digest` is `NULL`."]
    #[doc = "   - `signature` is `NULL`."]
    #[doc = "   - `ok` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub verify: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            mechanism: AZIOT_KEYS_SIGN_MECHANISM,
            parameters: *const ::std::os::raw::c_void,
            digest: *const ::std::os::raw::c_uchar,
            digest_len: usize,
            signature: *const ::std::os::raw::c_uchar,
            signature_len: usize,
            ok: *mut ::std::os::raw::c_int,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Encrypt the given plaintext using the key or key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_ENCRYPT_MECHANISM_*` constants."]
    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
    #[doc = ""]
    #[doc = " `plaintext` is a byte buffer containing the data that must be encrypted."]
    #[doc = " The caller sets `plaintext_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `ciphertext` is an output byte buffer allocated by the caller to store the encrypted data."]
    #[doc = " The caller sets `ciphertext_len` to the address of the length of the buffer."]
    #[doc = " The implementation populates `ciphertext` with the ciphertext and sets `ciphertext_len` to the number of bytes it wrote to `ciphertext`."]
    #[doc = ""]
    #[doc = " It is allowed for the caller to call the function with `ciphertext` set to `NULL`. In this case the implementation calculates"]
    #[doc = " an upper bound for how many bytes will be needed to store the ciphertext, sets that in `ciphertext_len` and returns."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key or key pair specified by `id` does not exist."]
    #[doc = "   - `mechanism` is not a valid encryption mechanism for the key or key pair specified by `id`."]
    #[doc = "   - `parameters` is invalid."]
    #[doc = "   - `plaintext` is `NULL`."]
    #[doc = "   - `ciphertext` is insufficiently large to hold the ciphertext."]
    #[doc = "   - `ciphertext_len` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub encrypt: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            mechanism: AZIOT_KEYS_ENCRYPT_MECHANISM,
            parameters: *const ::std::os::raw::c_void,
            plaintext: *const ::std::os::raw::c_uchar,
            plaintext_len: usize,
            ciphertext: *mut ::std::os::raw::c_uchar,
            ciphertext_len: *mut usize,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Decrypt the given plaintext using the key or key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_ENCRYPT_MECHANISM_*` constants."]
    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
    #[doc = ""]
    #[doc = " `ciphertext` is a byte buffer containing the data that must be signed."]
    #[doc = " The caller sets `ciphertext_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `plaintext` is an output byte buffer allocated by the caller to store the decrypted data."]
    #[doc = " The caller sets `plaintext_len` to the address of the length of the buffer."]
    #[doc = " The implementation populates `plaintext` with the plaintext and sets `plaintext_len` to the number of bytes it wrote to `plaintext`."]
    #[doc = ""]
    #[doc = " It is allowed for the caller to call the function with `plaintext` set to `NULL`. In this case the implementation calculates"]
    #[doc = " an upper bound for how many bytes will be needed to store the plaintext, sets that in `plaintext_len` and returns."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key or key pair specified by `id` does not exist."]
    #[doc = "   - `mechanism` is not a valid encryption mechanism for the key or key pair specified by `id`."]
    #[doc = "   - `parameters` is invalid."]
    #[doc = "   - `ciphertext` is `NULL`."]
    #[doc = "   - `plaintext` is insufficiently large to hold the ciphertext."]
    #[doc = "   - `plaintext_len` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub decrypt: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            mechanism: AZIOT_KEYS_ENCRYPT_MECHANISM,
            parameters: *const ::std::os::raw::c_void,
            ciphertext: *const ::std::os::raw::c_uchar,
            ciphertext_len: usize,
            plaintext: *mut ::std::os::raw::c_uchar,
            plaintext_len: *mut usize,
        ) -> AZIOT_KEYS_RC,
    >,
}
#[test]
fn bindgen_test_layout_AZIOT_KEYS_FUNCTION_LIST_2_0_0_0() {
    assert_eq!(
        ::std::mem::size_of::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>(),
        104usize,
        concat!("Size of: ", stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0))
    );
    assert_eq!(
        ::std::mem::align_of::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).base as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).set_parameter as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(set_parameter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>()))
                .create_key_pair_if_not_exists as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(create_key_pair_if_not_exists)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).load_key_pair as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(load_key_pair)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).get_key_pair_parameter
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(get_key_pair_parameter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).create_key_if_not_exists
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(create_key_if_not_exists)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).load_key as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(load_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).import_key as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(import_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).derive_key as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(derive_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).sign as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).verify as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).encrypt as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(encrypt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).decrypt as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
            "::",
            stringify!(decrypt)
        )
    );
}
#[doc = " The specific implementation of [`AZIOT_KEYS_FUNCTION_LIST`] for API version 2.1.0.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AZIOT_KEYS_FUNCTION_LIST_2_1_0_0 {
    #[doc = " The value of `base.version` must be [`AZIOT_KEYS_VERSION_2_1_0_0`]."]
    pub base: AZIOT_KEYS_FUNCTION_LIST,
    #[doc = " Set a parameter on this library."]
    #[doc = ""]
    #[doc = " `name` must not be `NULL`."]
    #[doc = " `value` may be `NULL`."]
    #[doc = ""]
    #[doc = " The caller may free the name string after this method returns. If the implementation needs to hold on to it, it must make a copy."]
    #[doc = ""]
    #[doc = " The interpretation of names and values depends on the implementation. A special case is for names that start with `preloaded_key:`,"]
    #[doc = " such as `preloaded_key:foo`. This defines a user-provided association of the key ID \"foo\" with the location specified by `value`."]
    #[doc = " Any call that uses the key with ID \"foo\" must use the location specified by `value`. Note that this does not mean the key already exists"]
    #[doc = " at that location; but it does mean that `create_key_if_not_exists` (for example) must create the key at that location and not any other."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `name` is `NULL`."]
    #[doc = "   - `name` is not recognized by this implementation, or invalid in some other way."]
    #[doc = "   - `value` is invalid."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub set_parameter: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Create or load a key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " - If a key pair with that ID exists and can be loaded, it will be left as-is."]
    #[doc = " - If a key pair with that ID does not exist, a new key will be created. It will be saved such that it can be looked up later using that same ID."]
    #[doc = ""]
    #[doc = " `preferred_algorithms` dictates the caller's preference for the key algorithm. It is a string with components separated by COLON U+003A `:`,"]
    #[doc = " where each component specifies the name of an algorithm and will be attempted by the implementation in that order."]
    #[doc = " The valid components are `\"ec-p256\"` for secp256r1, `\"rsa-2048\"` for 2048-bit RSA, `\"rsa-4096\"` for 4096-bit RSA, and `\"*\"` which indicates"]
    #[doc = " any algorithm of the implementation's choice. For example, the caller might use `\"ec-p256:rsa-2048:*\"` to indicate that it would like"]
    #[doc = " the implementation to use secp256r1, else RSA-2048 if that fails, else any other algorithm of the implementation's choice if that also fails."]
    #[doc = ""]
    #[doc = " If an implementation does not recognize a particular component as an algorithm, or is unable to use the algorithm to generate a key pair,"]
    #[doc = " it must ignore that component and try the next one. If no components are left, the implementation returns an error."]
    #[doc = " The implementation is allowed to be unable to generate a key pair regardless of which algorithms are specified; this is true even if"]
    #[doc = " the wildcard algorithm is specified."]
    #[doc = ""]
    #[doc = " If `preferred_algorithms` is `NULL`, it must be interpreted the same as if it was `\"*\"`."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - `preferred_algorithms` is invalid."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub create_key_pair_if_not_exists: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            preferred_algorithms: *const ::std::os::raw::c_char,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Move an existing key pair to another `id`."]
    #[doc = ""]
    #[doc = " This function replaces any existing key and the destination `id`."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - either `from` or `to` is `NULL`."]
    #[doc = "   - either `from` or `to` is invalid."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub move_key_pair: ::std::option::Option<
        unsafe extern "C" fn(
            from: *const ::std::os::raw::c_char,
            to: *const ::std::os::raw::c_char,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Load an existing key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " This validates that a key pair with the given ID exists and can be loaded."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub load_key_pair: ::std::option::Option<
        unsafe extern "C" fn(id: *const ::std::os::raw::c_char) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Get the value of a parameter of the key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " `type_` must be set to one of the `AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_*` constants."]
    #[doc = ""]
    #[doc = " `value` is an output byte buffer allocated by the caller to store the parameter value."]
    #[doc = " The caller sets `value_len` to the address of the length of the buffer."]
    #[doc = " The implementation populates `value` with the parameter value and sets `value_len` to the number of bytes it wrote to `value`."]
    #[doc = ""]
    #[doc = " It is allowed for the caller to call the function with `value` set to `NULL`. In this case the implementation calculates"]
    #[doc = " an upper bound for how many bytes will be needed to store the parameter value, sets that in `value_len` and returns."]
    #[doc = ""]
    #[doc = " The format of the data stored in `value` is determined by the `type_`. See the documentation of those constants for details."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key pair specified by `id` does not exist."]
    #[doc = "   - `type_` is not a valid parameter type for the key pair specified by `id`."]
    #[doc = "   - `value` is insufficiently large to hold the parameter value."]
    #[doc = "   - `value_len` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub get_key_pair_parameter: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            type_: AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE,
            value: *mut ::std::os::raw::c_uchar,
            value_len: *mut usize,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Delete an existing key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " This function succeeds if a key with the specified ID doesn't already exist."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub delete_key_pair: ::std::option::Option<
        unsafe extern "C" fn(id: *const ::std::os::raw::c_char) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Create or load a key identified by the specified `id`."]
    #[doc = ""]
    #[doc = " - If a key with that ID exists and can be loaded, it will be left as-is."]
    #[doc = " - If a key with that ID does not exist, a new random key will be created."]
    #[doc = "   It will be saved such that it can be looked up later using that same ID."]
    #[doc = ""]
    #[doc = " `usage` specifies what the key will be used for."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub create_key_if_not_exists: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            usage: AZIOT_KEYS_KEY_USAGE,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Load an existing key identified by the specified `id`."]
    #[doc = ""]
    #[doc = " This validates that a key with the given ID exists and can be loaded."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key specified by `id` does not exist."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub load_key: ::std::option::Option<
        unsafe extern "C" fn(id: *const ::std::os::raw::c_char) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Import a symmetric key with the given `id`."]
    #[doc = ""]
    #[doc = " It will be saved such that it can be looked up later using that same ID."]
    #[doc = ""]
    #[doc = " If a key with that ID already exists, the existing key will be overwritten."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - `bytes` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub import_key: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            bytes: *const u8,
            bytes_len: usize,
            usage: AZIOT_KEYS_KEY_USAGE,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Delete an existing key identified by the specified `id`."]
    #[doc = ""]
    #[doc = " This function succeeds if a key with the specified ID doesn't already exist."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub delete_key: ::std::option::Option<
        unsafe extern "C" fn(id: *const ::std::os::raw::c_char) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Derive a key with a given base key using some derivation data, and return the derived key."]
    #[doc = ""]
    #[doc = " The derivation process used by this function must be identical to"]
    #[doc = " the derivation process used by `encrypt` with the `AZIOT_KEYS_ENCRYPT_MECHANISM_DERIVED` mechanism and"]
    #[doc = " the derivation process used by `sign` with the `AZIOT_KEYS_SIGN_MECHANISM_DERIVED` mechanism."]
    #[doc = ""]
    #[doc = " `base_id` is the ID of the key that will be used to derive the new key. The key must have been created / imported"]
    #[doc = " with the [`crate::AZIOT_KEYS_KEY_USAGE_DERIVE`] usage."]
    #[doc = ""]
    #[doc = " `derivation_data` is a byte buffer containing the data that used for the derivation."]
    #[doc = " The caller sets `derivation_data_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `derived_key` is an output byte buffer allocated by the caller to store the derived key."]
    #[doc = " The caller sets `derived_key_len` to the address of the length of the buffer."]
    #[doc = " The implementation populates `derived_key` with the parameter derived_key and sets `derived_key_len` to the number of bytes it wrote to `derived_key`."]
    #[doc = ""]
    #[doc = " It is allowed for the caller to call the function with `derived_key` set to `NULL`. In this case the implementation calculates"]
    #[doc = " an upper bound for how many bytes will be needed to store the derived key, sets that in `derived_key_len` and returns."]
    #[doc = ""]
    #[doc = " The new key is not persisted by the implementation, only returned in `derived_key`."]
    #[doc = " If the caller wishes to persist it, they can import it with `import_key`."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `base_id` is `NULL`."]
    #[doc = "   - `base_id` is invalid."]
    #[doc = "   - The key specified by `base_id` does not exist."]
    #[doc = "   - `derivation_data` is `NULL`."]
    #[doc = "   - `derived_key` is insufficiently large to hold the parameter value."]
    #[doc = "   - `derived_key_len` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub derive_key: ::std::option::Option<
        unsafe extern "C" fn(
            base_id: *const ::std::os::raw::c_char,
            derivation_data: *const u8,
            derivation_data_len: usize,
            derived_key: *mut ::std::os::raw::c_uchar,
            derived_key_len: *mut usize,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Sign the given digest using the key or key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_SIGN_MECHANISM_*` constants."]
    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
    #[doc = ""]
    #[doc = " `digest` is a byte buffer containing the data that must be signed."]
    #[doc = " The caller sets `digest_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `signature` is an output byte buffer allocated by the caller to store the signature."]
    #[doc = " The caller sets `signature_len` to the address of the length of the buffer."]
    #[doc = " The implementation populates `signature` with the signature and sets `signature_len` to the number of bytes it wrote to `signature`."]
    #[doc = ""]
    #[doc = " It is allowed for the caller to call the function with `signature` set to `NULL`. In this case the implementation calculates"]
    #[doc = " an upper bound for how many bytes will be needed to store the signature, sets that in `signature_len` and returns."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key or key pair specified by `id` does not exist."]
    #[doc = "   - `mechanism` is not a valid signature mechanism for the key or key pair specified by `id`."]
    #[doc = "   - `parameters` is invalid."]
    #[doc = "   - `digest` is `NULL`."]
    #[doc = "   - `signature` is insufficiently large to hold the signature."]
    #[doc = "   - `signature_len` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub sign: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            mechanism: AZIOT_KEYS_SIGN_MECHANISM,
            parameters: *const ::std::os::raw::c_void,
            digest: *const ::std::os::raw::c_uchar,
            digest_len: usize,
            signature: *mut ::std::os::raw::c_uchar,
            signature_len: *mut usize,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Verify the signature of the given digest using the key or key pair (but see note below) identified by the specified `id`."]
    #[doc = ""]
    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_SIGN_MECHANISM_*` constants."]
    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
    #[doc = ""]
    #[doc = " `digest` is a byte buffer containing the data that must be signed."]
    #[doc = " The caller sets `digest_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `signature` is a byte buffer containing the signature that the caller expects the data to have."]
    #[doc = " The caller sets `signature_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `ok` is an output parameter that stores whether the signature could be verified or not."]
    #[doc = " If the function is able to compute the signature of the data, it sets `ok` and returns `AZIOT_KEYS_RC_OK`."]
    #[doc = " `ok` is set to 0 if the signature is invalid and non-zero if the signature is valid."]
    #[doc = " The value stored in `ok` is only meaningful if the function returns `AZIOT_KEYS_RC_OK`, otherwise it must be ignored."]
    #[doc = ""]
    #[doc = " Note: The implementation is not required to support verification with key pairs, ie `AZIOT_KEYS_SIGN_MECHANISM_ECDSA`."]
    #[doc = " The caller can do the verification themselves with the public parameters of the EC key as obtained via `get_key_pair_parameter`."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key or key pair specified by `id` does not exist."]
    #[doc = "   - `mechanism` is not a valid signature mechanism for the key or key pair specified by `id`."]
    #[doc = "   - `parameters` is invalid."]
    #[doc = "   - `digest` is `NULL`."]
    #[doc = "   - `signature` is `NULL`."]
    #[doc = "   - `ok` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub verify: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            mechanism: AZIOT_KEYS_SIGN_MECHANISM,
            parameters: *const ::std::os::raw::c_void,
            digest: *const ::std::os::raw::c_uchar,
            digest_len: usize,
            signature: *const ::std::os::raw::c_uchar,
            signature_len: usize,
            ok: *mut ::std::os::raw::c_int,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Encrypt the given plaintext using the key or key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_ENCRYPT_MECHANISM_*` constants."]
    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
    #[doc = ""]
    #[doc = " `plaintext` is a byte buffer containing the data that must be encrypted."]
    #[doc = " The caller sets `plaintext_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `ciphertext` is an output byte buffer allocated by the caller to store the encrypted data."]
    #[doc = " The caller sets `ciphertext_len` to the address of the length of the buffer."]
    #[doc = " The implementation populates `ciphertext` with the ciphertext and sets `ciphertext_len` to the number of bytes it wrote to `ciphertext`."]
    #[doc = ""]
    #[doc = " It is allowed for the caller to call the function with `ciphertext` set to `NULL`. In this case the implementation calculates"]
    #[doc = " an upper bound for how many bytes will be needed to store the ciphertext, sets that in `ciphertext_len` and returns."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key or key pair specified by `id` does not exist."]
    #[doc = "   - `mechanism` is not a valid encryption mechanism for the key or key pair specified by `id`."]
    #[doc = "   - `parameters` is invalid."]
    #[doc = "   - `plaintext` is `NULL`."]
    #[doc = "   - `ciphertext` is insufficiently large to hold the ciphertext."]
    #[doc = "   - `ciphertext_len` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub encrypt: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            mechanism: AZIOT_KEYS_ENCRYPT_MECHANISM,
            parameters: *const ::std::os::raw::c_void,
            plaintext: *const ::std::os::raw::c_uchar,
            plaintext_len: usize,
            ciphertext: *mut ::std::os::raw::c_uchar,
            ciphertext_len: *mut usize,
        ) -> AZIOT_KEYS_RC,
    >,
    #[doc = " Decrypt the given plaintext using the key or key pair identified by the specified `id`."]
    #[doc = ""]
    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_ENCRYPT_MECHANISM_*` constants."]
    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
    #[doc = ""]
    #[doc = " `ciphertext` is a byte buffer containing the data that must be signed."]
    #[doc = " The caller sets `ciphertext_len` to the length of the buffer."]
    #[doc = ""]
    #[doc = " `plaintext` is an output byte buffer allocated by the caller to store the decrypted data."]
    #[doc = " The caller sets `plaintext_len` to the address of the length of the buffer."]
    #[doc = " The implementation populates `plaintext` with the plaintext and sets `plaintext_len` to the number of bytes it wrote to `plaintext`."]
    #[doc = ""]
    #[doc = " It is allowed for the caller to call the function with `plaintext` set to `NULL`. In this case the implementation calculates"]
    #[doc = " an upper bound for how many bytes will be needed to store the plaintext, sets that in `plaintext_len` and returns."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `id` is `NULL`."]
    #[doc = "   - `id` is invalid."]
    #[doc = "   - The key or key pair specified by `id` does not exist."]
    #[doc = "   - `mechanism` is not a valid encryption mechanism for the key or key pair specified by `id`."]
    #[doc = "   - `parameters` is invalid."]
    #[doc = "   - `ciphertext` is `NULL`."]
    #[doc = "   - `plaintext` is insufficiently large to hold the ciphertext."]
    #[doc = "   - `plaintext_len` is `NULL`."]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
    pub decrypt: ::std::option::Option<
        unsafe extern "C" fn(
            id: *const ::std::os::raw::c_char,
            mechanism: AZIOT_KEYS_ENCRYPT_MECHANISM,
            parameters: *const ::std::os::raw::c_void,
            ciphertext: *const ::std::os::raw::c_uchar,
            ciphertext_len: usize,
            plaintext: *mut ::std::os::raw::c_uchar,
            plaintext_len: *mut usize,
        ) -> AZIOT_KEYS_RC,
    >,
}
#[test]
fn bindgen_test_layout_AZIOT_KEYS_FUNCTION_LIST_2_1_0_0() {
    assert_eq!(
        ::std::mem::size_of::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>(),
        128usize,
        concat!("Size of: ", stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0))
    );
    assert_eq!(
        ::std::mem::align_of::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).base as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).set_parameter as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(set_parameter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>()))
                .create_key_pair_if_not_exists as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(create_key_pair_if_not_exists)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).move_key_pair as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(move_key_pair)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).load_key_pair as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(load_key_pair)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).get_key_pair_parameter
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(get_key_pair_parameter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).delete_key_pair as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(delete_key_pair)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).create_key_if_not_exists
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(create_key_if_not_exists)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).load_key as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(load_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).import_key as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(import_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).delete_key as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(delete_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).derive_key as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(derive_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).sign as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).verify as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).encrypt as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(encrypt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_1_0_0>())).decrypt as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_1_0_0),
            "::",
            stringify!(decrypt)
        )
    );
}
#[doc = " The algorithm of a key pair, as returned by `get_key_pair_parameter`."]
#[doc = ""]
#[doc = " One of the `AZIOT_KEYS_KEY_PAIR_PARAMETER_ALGORITHM_*` constants."]
pub type AZIOT_KEYS_KEY_PAIR_PARAMETER_ALGORITHM = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Get the list of functions for operations corresponding to the specified version."]
    #[doc = ""]
    #[doc = " Implementations can use this function for initialization, since it is guaranteed to be called before any operations."]
    #[doc = " However it is not an error to call this function multiple times, for the same or different version,"]
    #[doc = " so implementations must ensure they only run their initialization once."]
    #[doc = ""]
    #[doc = " The pointer returned from this function must not be freed by the caller, and its contents must not be mutated."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
    #[doc = "   - `version` is not recognized by this implementation."]
    #[doc = "   - `pfunction_list` is `NULL`."]
    pub fn aziot_keys_get_function_list(
        version: AZIOT_KEYS_VERSION,
        pfunction_list: *mut *const AZIOT_KEYS_FUNCTION_LIST,
    ) -> AZIOT_KEYS_RC;
}
