From de1d43614b581c9600ebfb2490bda1613e6ed869 Mon Sep 17 00:00:00 2001
From: Pierrick Curt <pierrick.curt@rtone.fr>
Date: Tue, 27 Apr 2021 19:26:47 +0000
Subject: [PATCH] Add aziot-keys.h (unused) in current recipe version

---
 key/aziot-keyd/src/keys.generated.rs | 906 +++++++++++++++++++++++++++
 key/aziot-keys/aziot-keys.h          |  14 +-
 2 files changed, 913 insertions(+), 7 deletions(-)
 create mode 100644 key/aziot-keyd/src/keys.generated.rs

diff --git a/key/aziot-keyd/src/keys.generated.rs b/key/aziot-keyd/src/keys.generated.rs
new file mode 100644
index 0000000..860feeb
--- /dev/null
+++ b/key/aziot-keyd/src/keys.generated.rs
@@ -0,0 +1,906 @@
+/* automatically generated by rust-bindgen 0.58.1 */
+
+pub const AZIOT_KEYS_RC_OK: u32 = 0;
+pub const AZIOT_KEYS_RC_ERR_INVALID_PARAMETER: u32 = 1;
+pub const AZIOT_KEYS_RC_ERR_EXTERNAL: u32 = 2;
+pub const AZIOT_KEYS_VERSION_2_0_0_0: u32 = 33554432;
+pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_ALGORITHM: u32 = 1;
+pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_EC_CURVE_OID: u32 = 2;
+pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_EC_POINT: u32 = 3;
+pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_RSA_MODULUS: u32 = 4;
+pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_RSA_EXPONENT: u32 = 5;
+pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_ALGORITHM_EC: u32 = 1;
+pub const AZIOT_KEYS_KEY_PAIR_PARAMETER_ALGORITHM_RSA: u32 = 2;
+pub const AZIOT_KEYS_KEY_USAGE_DERIVE: u32 = 1;
+pub const AZIOT_KEYS_KEY_USAGE_ENCRYPT: u32 = 16;
+pub const AZIOT_KEYS_KEY_USAGE_SIGN: u32 = 1;
+pub const AZIOT_KEYS_SIGN_MECHANISM_ECDSA: u32 = 1;
+pub const AZIOT_KEYS_SIGN_MECHANISM_HMAC_SHA256: u32 = 2;
+pub const AZIOT_KEYS_SIGN_MECHANISM_DERIVED: u32 = 3;
+pub const AZIOT_KEYS_ENCRYPT_MECHANISM_AEAD: u32 = 1;
+pub const AZIOT_KEYS_ENCRYPT_MECHANISM_RSA_PKCS1: u32 = 2;
+pub const AZIOT_KEYS_ENCRYPT_MECHANISM_RSA_NO_PADDING: u32 = 3;
+pub const AZIOT_KEYS_ENCRYPT_MECHANISM_DERIVED: u32 = 4;
+#[doc = " Represents the version of the API exported by this library."]
+pub type AZIOT_KEYS_VERSION = ::std::os::raw::c_uint;
+#[doc = " The base struct of all of function lists."]
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct AZIOT_KEYS_FUNCTION_LIST {
+    #[doc = " The version of the API represented in this function list."]
+    #[doc = ""]
+    #[doc = " The specific subtype of `AZIOT_KEYS_FUNCTION_LIST` can be determined by inspecting this value."]
+    pub version: AZIOT_KEYS_VERSION,
+}
+#[test]
+fn bindgen_test_layout_AZIOT_KEYS_FUNCTION_LIST() {
+    assert_eq!(
+        ::std::mem::size_of::<AZIOT_KEYS_FUNCTION_LIST>(),
+        4usize,
+        concat!("Size of: ", stringify!(AZIOT_KEYS_FUNCTION_LIST))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<AZIOT_KEYS_FUNCTION_LIST>(),
+        4usize,
+        concat!("Alignment of ", stringify!(AZIOT_KEYS_FUNCTION_LIST))
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST>())).version as *const _ as usize
+        },
+        0usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST),
+            "::",
+            stringify!(version)
+        )
+    );
+}
+#[doc = " Return code of a function. This is a transparent wrapper around a `std::os::raw::c_uint` (`unsigned int`)."]
+#[doc = ""]
+#[doc = " One of the `AZIOT_KEYS_RC_ERR_*` constants."]
+pub type AZIOT_KEYS_RC = ::std::os::raw::c_uint;
+#[doc = " Used as the parameter type with `get_key_pair_parameter`."]
+#[doc = ""]
+#[doc = " One of the `AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_*` constants."]
+pub type AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE = ::std::os::raw::c_uint;
+#[doc = " The usage of key being created with `create_key_if_not_exists` or"]
+#[doc = " being imported with `import_key`."]
+#[doc = ""]
+#[doc = " This is a bitflag type, so its values can be combined. But note that not all combinations of flags"]
+#[doc = " are valid."]
+pub type AZIOT_KEYS_KEY_USAGE = ::std::os::raw::c_uint;
+#[doc = " The mechanism used with `sign` / `verify`."]
+#[doc = ""]
+#[doc = " One of the `AZIOT_KEYS_SIGN_MECHANISM_*` constants."]
+pub type AZIOT_KEYS_SIGN_MECHANISM = ::std::os::raw::c_uint;
+#[doc = " The mechanism used with `encrypt` / `decrypt`."]
+#[doc = ""]
+#[doc = " One of the `AZIOT_KEYS_ENCRYPT_MECHANISM_*` constants."]
+pub type AZIOT_KEYS_ENCRYPT_MECHANISM = ::std::os::raw::c_uint;
+#[doc = " The specific implementation of [`AZIOT_KEYS_FUNCTION_LIST`] for API version 2.0.0.0"]
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct AZIOT_KEYS_FUNCTION_LIST_2_0_0_0 {
+    #[doc = " The value of `base.version` must be [`AZIOT_KEYS_VERSION_2_0_0_0`]."]
+    pub base: AZIOT_KEYS_FUNCTION_LIST,
+    #[doc = " Set a parameter on this library."]
+    #[doc = ""]
+    #[doc = " `name` must not be `NULL`."]
+    #[doc = " `value` may be `NULL`."]
+    #[doc = ""]
+    #[doc = " The caller may free the name string after this method returns. If the implementation needs to hold on to it, it must make a copy."]
+    #[doc = ""]
+    #[doc = " The interpretation of names and values depends on the implementation. A special case is for names that start with `preloaded_key:`,"]
+    #[doc = " such as `preloaded_key:foo`. This defines a user-provided association of the key ID \"foo\" with the location specified by `value`."]
+    #[doc = " Any call that uses the key with ID \"foo\" must use the location specified by `value`. Note that this does not mean the key already exists"]
+    #[doc = " at that location; but it does mean that `create_key_if_not_exists` (for example) must create the key at that location and not any other."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `name` is `NULL`."]
+    #[doc = "   - `name` is not recognized by this implementation, or invalid in some other way."]
+    #[doc = "   - `value` is invalid."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub set_parameter: ::std::option::Option<
+        unsafe extern "C" fn(
+            name: *const ::std::os::raw::c_char,
+            value: *const ::std::os::raw::c_char,
+        ) -> AZIOT_KEYS_RC,
+    >,
+    #[doc = " Create or load a key pair identified by the specified `id`."]
+    #[doc = ""]
+    #[doc = " - If a key pair with that ID exists and can be loaded, it will be left as-is."]
+    #[doc = " - If a key pair with that ID does not exist, a new key will be created. It will be saved such that it can be looked up later using that same ID."]
+    #[doc = ""]
+    #[doc = " `preferred_algorithms` dictates the caller's preference for the key algorithm. It is a string with components separated by COLON U+003A `:`,"]
+    #[doc = " where each component specifies the name of an algorithm and will be attempted by the implementation in that order."]
+    #[doc = " The valid components are `\"ec-p256\"` for secp256r1, `\"rsa-2048\"` for 2048-bit RSA, `\"rsa-4096\"` for 4096-bit RSA, and `\"*\"` which indicates"]
+    #[doc = " any algorithm of the implementation's choice. For example, the caller might use `\"ec-p256:rsa-2048:*\"` to indicate that it would like"]
+    #[doc = " the implementation to use secp256r1, else RSA-2048 if that fails, else any other algorithm of the implementation's choice if that also fails."]
+    #[doc = ""]
+    #[doc = " If an implementation does not recognize a particular component as an algorithm, or is unable to use the algorithm to generate a key pair,"]
+    #[doc = " it must ignore that component and try the next one. If no components are left, the implementation returns an error."]
+    #[doc = " The implementation is allowed to be unable to generate a key pair regardless of which algorithms are specified; this is true even if"]
+    #[doc = " the wildcard algorithm is specified."]
+    #[doc = ""]
+    #[doc = " If `preferred_algorithms` is `NULL`, it must be interpreted the same as if it was `\"*\"`."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `id` is `NULL`."]
+    #[doc = "   - `id` is invalid."]
+    #[doc = "   - `preferred_algorithms` is invalid."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub create_key_pair_if_not_exists: ::std::option::Option<
+        unsafe extern "C" fn(
+            id: *const ::std::os::raw::c_char,
+            preferred_algorithms: *const ::std::os::raw::c_char,
+        ) -> AZIOT_KEYS_RC,
+    >,
+    #[doc = " Load an existing key pair identified by the specified `id`."]
+    #[doc = ""]
+    #[doc = " This validates that a key pair with the given ID exists and can be loaded."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `id` is `NULL`."]
+    #[doc = "   - `id` is invalid."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub load_key_pair: ::std::option::Option<
+        unsafe extern "C" fn(id: *const ::std::os::raw::c_char) -> AZIOT_KEYS_RC,
+    >,
+    #[doc = " Get the value of a parameter of the key pair identified by the specified `id`."]
+    #[doc = ""]
+    #[doc = " `type_` must be set to one of the `AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE_*` constants."]
+    #[doc = ""]
+    #[doc = " `value` is an output byte buffer allocated by the caller to store the parameter value."]
+    #[doc = " The caller sets `value_len` to the address of the length of the buffer."]
+    #[doc = " The implementation populates `value` with the parameter value and sets `value_len` to the number of bytes it wrote to `value`."]
+    #[doc = ""]
+    #[doc = " It is allowed for the caller to call the function with `value` set to `NULL`. In this case the implementation calculates"]
+    #[doc = " an upper bound for how many bytes will be needed to store the parameter value, sets that in `value_len` and returns."]
+    #[doc = ""]
+    #[doc = " The format of the data stored in `value` is determined by the `type_`. See the documentation of those constants for details."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `id` is `NULL`."]
+    #[doc = "   - `id` is invalid."]
+    #[doc = "   - The key pair specified by `id` does not exist."]
+    #[doc = "   - `type_` is not a valid parameter type for the key pair specified by `id`."]
+    #[doc = "   - `value` is insufficiently large to hold the parameter value."]
+    #[doc = "   - `value_len` is `NULL`."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub get_key_pair_parameter: ::std::option::Option<
+        unsafe extern "C" fn(
+            id: *const ::std::os::raw::c_char,
+            type_: AZIOT_KEYS_KEY_PAIR_PARAMETER_TYPE,
+            value: *mut ::std::os::raw::c_uchar,
+            value_len: *mut usize,
+        ) -> AZIOT_KEYS_RC,
+    >,
+    #[doc = " Create or load a key identified by the specified `id`."]
+    #[doc = ""]
+    #[doc = " - If a key with that ID exists and can be loaded, it will be left as-is."]
+    #[doc = " - If a key with that ID does not exist, a new random key will be created."]
+    #[doc = "   It will be saved such that it can be looked up later using that same ID."]
+    #[doc = ""]
+    #[doc = " `usage` specifies what the key will be used for."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `id` is `NULL`."]
+    #[doc = "   - `id` is invalid."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub create_key_if_not_exists: ::std::option::Option<
+        unsafe extern "C" fn(
+            id: *const ::std::os::raw::c_char,
+            usage: AZIOT_KEYS_KEY_USAGE,
+        ) -> AZIOT_KEYS_RC,
+    >,
+    #[doc = " Load an existing key identified by the specified `id`."]
+    #[doc = ""]
+    #[doc = " This validates that a key with the given ID exists and can be loaded."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `id` is `NULL`."]
+    #[doc = "   - `id` is invalid."]
+    #[doc = "   - The key specified by `id` does not exist."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub load_key: ::std::option::Option<
+        unsafe extern "C" fn(id: *const ::std::os::raw::c_char) -> AZIOT_KEYS_RC,
+    >,
+    #[doc = " Import a symmetric key with the given `id`."]
+    #[doc = ""]
+    #[doc = " It will be saved such that it can be looked up later using that same ID."]
+    #[doc = ""]
+    #[doc = " If a key with that ID already exists, the existing key will be overwritten."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `id` is `NULL`."]
+    #[doc = "   - `id` is invalid."]
+    #[doc = "   - `bytes` is `NULL`."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub import_key: ::std::option::Option<
+        unsafe extern "C" fn(
+            id: *const ::std::os::raw::c_char,
+            bytes: *const u8,
+            bytes_len: usize,
+            usage: AZIOT_KEYS_KEY_USAGE,
+        ) -> AZIOT_KEYS_RC,
+    >,
+    #[doc = " Derive a key with a given base key using some derivation data, and return the derived key."]
+    #[doc = ""]
+    #[doc = " The derivation process used by this function must be identical to"]
+    #[doc = " the derivation process used by `encrypt` with the `AZIOT_KEYS_ENCRYPT_MECHANISM_DERIVED` mechanism and"]
+    #[doc = " the derivation process used by `sign` with the `AZIOT_KEYS_SIGN_MECHANISM_DERIVED` mechanism."]
+    #[doc = ""]
+    #[doc = " `base_id` is the ID of the key that will be used to derive the new key. The key must have been created / imported"]
+    #[doc = " with the [`AZIOT_KEYS_KEY_USAGE_DERIVE`] usage."]
+    #[doc = ""]
+    #[doc = " `derivation_data` is a byte buffer containing the data that used for the derivation."]
+    #[doc = " The caller sets `derivation_data_len` to the length of the buffer."]
+    #[doc = ""]
+    #[doc = " `derived_key` is an output byte buffer allocated by the caller to store the derived key."]
+    #[doc = " The caller sets `derived_key_len` to the address of the length of the buffer."]
+    #[doc = " The implementation populates `derived_key` with the parameter derived_key and sets `derived_key_len` to the number of bytes it wrote to `derived_key`."]
+    #[doc = ""]
+    #[doc = " It is allowed for the caller to call the function with `derived_key` set to `NULL`. In this case the implementation calculates"]
+    #[doc = " an upper bound for how many bytes will be needed to store the derived key, sets that in `derived_key_len` and returns."]
+    #[doc = ""]
+    #[doc = " The new key is not persisted by the implementation, only returned in `derived_key`."]
+    #[doc = " If the caller wishes to persist it, they can import it with `import_key`."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `base_id` is `NULL`."]
+    #[doc = "   - `base_id` is invalid."]
+    #[doc = "   - The key specified by `base_id` does not exist."]
+    #[doc = "   - `derivation_data` is `NULL`."]
+    #[doc = "   - `derived_key` is insufficiently large to hold the parameter value."]
+    #[doc = "   - `derived_key_len` is `NULL`."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub derive_key: ::std::option::Option<
+        unsafe extern "C" fn(
+            base_id: *const ::std::os::raw::c_char,
+            derivation_data: *const u8,
+            derivation_data_len: usize,
+            derived_key: *mut ::std::os::raw::c_uchar,
+            derived_key_len: *mut usize,
+        ) -> AZIOT_KEYS_RC,
+    >,
+    #[doc = " Sign the given digest using the key or key pair identified by the specified `id`."]
+    #[doc = ""]
+    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_SIGN_MECHANISM_*` constants."]
+    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
+    #[doc = ""]
+    #[doc = " `digest` is a byte buffer containing the data that must be signed."]
+    #[doc = " The caller sets `digest_len` to the length of the buffer."]
+    #[doc = ""]
+    #[doc = " `signature` is an output byte buffer allocated by the caller to store the signature."]
+    #[doc = " The caller sets `signature_len` to the address of the length of the buffer."]
+    #[doc = " The implementation populates `signature` with the signature and sets `signature_len` to the number of bytes it wrote to `signature`."]
+    #[doc = ""]
+    #[doc = " It is allowed for the caller to call the function with `signature` set to `NULL`. In this case the implementation calculates"]
+    #[doc = " an upper bound for how many bytes will be needed to store the signature, sets that in `signature_len` and returns."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `id` is `NULL`."]
+    #[doc = "   - `id` is invalid."]
+    #[doc = "   - The key or key pair specified by `id` does not exist."]
+    #[doc = "   - `mechanism` is not a valid signature mechanism for the key or key pair specified by `id`."]
+    #[doc = "   - `parameters` is invalid."]
+    #[doc = "   - `digest` is `NULL`."]
+    #[doc = "   - `signature` is insufficiently large to hold the signature."]
+    #[doc = "   - `signature_len` is `NULL`."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub sign: ::std::option::Option<
+        unsafe extern "C" fn(
+            id: *const ::std::os::raw::c_char,
+            mechanism: AZIOT_KEYS_SIGN_MECHANISM,
+            parameters: *const ::std::os::raw::c_void,
+            digest: *const ::std::os::raw::c_uchar,
+            digest_len: usize,
+            signature: *mut ::std::os::raw::c_uchar,
+            signature_len: *mut usize,
+        ) -> AZIOT_KEYS_RC,
+    >,
+    #[doc = " Verify the signature of the given digest using the key or key pair (but see note below) identified by the specified `id`."]
+    #[doc = ""]
+    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_SIGN_MECHANISM_*` constants."]
+    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
+    #[doc = ""]
+    #[doc = " `digest` is a byte buffer containing the data that must be signed."]
+    #[doc = " The caller sets `digest_len` to the length of the buffer."]
+    #[doc = ""]
+    #[doc = " `signature` is a byte buffer containing the signature that the caller expects the data to have."]
+    #[doc = " The caller sets `signature_len` to the length of the buffer."]
+    #[doc = ""]
+    #[doc = " `ok` is an output parameter that stores whether the signature could be verified or not."]
+    #[doc = " If the function is able to compute the signature of the data, it sets `ok` and returns `AZIOT_KEYS_RC_OK`."]
+    #[doc = " `ok` is set to 0 if the signature is invalid and non-zero if the signature is valid."]
+    #[doc = " The value stored in `ok` is only meaningful if the function returns `AZIOT_KEYS_RC_OK`, otherwise it must be ignored."]
+    #[doc = ""]
+    #[doc = " Note: The implementation is not required to support verification with key pairs, ie `AZIOT_KEYS_SIGN_MECHANISM_ECDSA`."]
+    #[doc = " The caller can do the verification themselves with the public parameters of the EC key as obtained via `get_key_pair_parameter`."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `id` is `NULL`."]
+    #[doc = "   - `id` is invalid."]
+    #[doc = "   - The key or key pair specified by `id` does not exist."]
+    #[doc = "   - `mechanism` is not a valid signature mechanism for the key or key pair specified by `id`."]
+    #[doc = "   - `parameters` is invalid."]
+    #[doc = "   - `digest` is `NULL`."]
+    #[doc = "   - `signature` is `NULL`."]
+    #[doc = "   - `ok` is `NULL`."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub verify: ::std::option::Option<
+        unsafe extern "C" fn(
+            id: *const ::std::os::raw::c_char,
+            mechanism: AZIOT_KEYS_SIGN_MECHANISM,
+            parameters: *const ::std::os::raw::c_void,
+            digest: *const ::std::os::raw::c_uchar,
+            digest_len: usize,
+            signature: *const ::std::os::raw::c_uchar,
+            signature_len: usize,
+            ok: *mut ::std::os::raw::c_int,
+        ) -> AZIOT_KEYS_RC,
+    >,
+    #[doc = " Encrypt the given plaintext using the key or key pair identified by the specified `id`."]
+    #[doc = ""]
+    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_ENCRYPT_MECHANISM_*` constants."]
+    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
+    #[doc = ""]
+    #[doc = " `plaintext` is a byte buffer containing the data that must be encrypted."]
+    #[doc = " The caller sets `plaintext_len` to the length of the buffer."]
+    #[doc = ""]
+    #[doc = " `ciphertext` is an output byte buffer allocated by the caller to store the encrypted data."]
+    #[doc = " The caller sets `ciphertext_len` to the address of the length of the buffer."]
+    #[doc = " The implementation populates `ciphertext` with the ciphertext and sets `ciphertext_len` to the number of bytes it wrote to `ciphertext`."]
+    #[doc = ""]
+    #[doc = " It is allowed for the caller to call the function with `ciphertext` set to `NULL`. In this case the implementation calculates"]
+    #[doc = " an upper bound for how many bytes will be needed to store the ciphertext, sets that in `ciphertext_len` and returns."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `id` is `NULL`."]
+    #[doc = "   - `id` is invalid."]
+    #[doc = "   - The key or key pair specified by `id` does not exist."]
+    #[doc = "   - `mechanism` is not a valid encryption mechanism for the key or key pair specified by `id`."]
+    #[doc = "   - `parameters` is invalid."]
+    #[doc = "   - `plaintext` is `NULL`."]
+    #[doc = "   - `ciphertext` is insufficiently large to hold the ciphertext."]
+    #[doc = "   - `ciphertext_len` is `NULL`."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub encrypt: ::std::option::Option<
+        unsafe extern "C" fn(
+            id: *const ::std::os::raw::c_char,
+            mechanism: AZIOT_KEYS_ENCRYPT_MECHANISM,
+            parameters: *const ::std::os::raw::c_void,
+            plaintext: *const ::std::os::raw::c_uchar,
+            plaintext_len: usize,
+            ciphertext: *mut ::std::os::raw::c_uchar,
+            ciphertext_len: *mut usize,
+        ) -> AZIOT_KEYS_RC,
+    >,
+    #[doc = " Decrypt the given plaintext using the key or key pair identified by the specified `id`."]
+    #[doc = ""]
+    #[doc = " `mechanism` must be set to one of the `AZIOT_KEYS_ENCRYPT_MECHANISM_*` constants."]
+    #[doc = " `parameters` must be set according to the `mechanism`, as documented on the constants."]
+    #[doc = ""]
+    #[doc = " `ciphertext` is a byte buffer containing the data that must be signed."]
+    #[doc = " The caller sets `ciphertext_len` to the length of the buffer."]
+    #[doc = ""]
+    #[doc = " `plaintext` is an output byte buffer allocated by the caller to store the decrypted data."]
+    #[doc = " The caller sets `plaintext_len` to the address of the length of the buffer."]
+    #[doc = " The implementation populates `plaintext` with the plaintext and sets `plaintext_len` to the number of bytes it wrote to `plaintext`."]
+    #[doc = ""]
+    #[doc = " It is allowed for the caller to call the function with `plaintext` set to `NULL`. In this case the implementation calculates"]
+    #[doc = " an upper bound for how many bytes will be needed to store the plaintext, sets that in `plaintext_len` and returns."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `id` is `NULL`."]
+    #[doc = "   - `id` is invalid."]
+    #[doc = "   - The key or key pair specified by `id` does not exist."]
+    #[doc = "   - `mechanism` is not a valid encryption mechanism for the key or key pair specified by `id`."]
+    #[doc = "   - `parameters` is invalid."]
+    #[doc = "   - `ciphertext` is `NULL`."]
+    #[doc = "   - `plaintext` is insufficiently large to hold the ciphertext."]
+    #[doc = "   - `plaintext_len` is `NULL`."]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_EXTERNAL`"]
+    pub decrypt: ::std::option::Option<
+        unsafe extern "C" fn(
+            id: *const ::std::os::raw::c_char,
+            mechanism: AZIOT_KEYS_ENCRYPT_MECHANISM,
+            parameters: *const ::std::os::raw::c_void,
+            ciphertext: *const ::std::os::raw::c_uchar,
+            ciphertext_len: usize,
+            plaintext: *mut ::std::os::raw::c_uchar,
+            plaintext_len: *mut usize,
+        ) -> AZIOT_KEYS_RC,
+    >,
+}
+#[test]
+fn bindgen_test_layout_AZIOT_KEYS_FUNCTION_LIST_2_0_0_0() {
+    assert_eq!(
+        ::std::mem::size_of::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>(),
+        104usize,
+        concat!("Size of: ", stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>(),
+        8usize,
+        concat!(
+            "Alignment of ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).base as *const _ as usize
+        },
+        0usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(base)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).set_parameter as *const _
+                as usize
+        },
+        8usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(set_parameter)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>()))
+                .create_key_pair_if_not_exists as *const _ as usize
+        },
+        16usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(create_key_pair_if_not_exists)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).load_key_pair as *const _
+                as usize
+        },
+        24usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(load_key_pair)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).get_key_pair_parameter
+                as *const _ as usize
+        },
+        32usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(get_key_pair_parameter)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).create_key_if_not_exists
+                as *const _ as usize
+        },
+        40usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(create_key_if_not_exists)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).load_key as *const _
+                as usize
+        },
+        48usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(load_key)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).import_key as *const _
+                as usize
+        },
+        56usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(import_key)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).derive_key as *const _
+                as usize
+        },
+        64usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(derive_key)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).sign as *const _ as usize
+        },
+        72usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(sign)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).verify as *const _ as usize
+        },
+        80usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(verify)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).encrypt as *const _
+                as usize
+        },
+        88usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(encrypt)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_FUNCTION_LIST_2_0_0_0>())).decrypt as *const _
+                as usize
+        },
+        96usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_FUNCTION_LIST_2_0_0_0),
+            "::",
+            stringify!(decrypt)
+        )
+    );
+}
+#[doc = " Used with `sign` / `verify` with the [`AZIOT_KEYS_SIGN_MECHANISM_DERIVED`] mechanism."]
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct AZIOT_KEYS_SIGN_DERIVED_PARAMETERS {
+    #[doc = " The data used to derive the new key."]
+    pub derivation_data: *const ::std::os::raw::c_uchar,
+    #[doc = " The length of the `derivation_data` buffer."]
+    pub derivation_data_len: usize,
+    #[doc = " The signature mechanism to use with the derived key."]
+    #[doc = ""]
+    #[doc = " One of the `AZIOT_KEYS_SIGN_MECHANISM_*` constants."]
+    pub mechanism: AZIOT_KEYS_SIGN_MECHANISM,
+    #[doc = " The parameters of the signature mechanism specified by `mechanism`."]
+    pub parameters: *const ::std::os::raw::c_void,
+}
+#[test]
+fn bindgen_test_layout_AZIOT_KEYS_SIGN_DERIVED_PARAMETERS() {
+    assert_eq!(
+        ::std::mem::size_of::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>(),
+        32usize,
+        concat!("Size of: ", stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>(),
+        8usize,
+        concat!(
+            "Alignment of ",
+            stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>())).derivation_data
+                as *const _ as usize
+        },
+        0usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS),
+            "::",
+            stringify!(derivation_data)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>())).derivation_data_len
+                as *const _ as usize
+        },
+        8usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS),
+            "::",
+            stringify!(derivation_data_len)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>())).mechanism as *const _
+                as usize
+        },
+        16usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS),
+            "::",
+            stringify!(mechanism)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_SIGN_DERIVED_PARAMETERS>())).parameters as *const _
+                as usize
+        },
+        24usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_SIGN_DERIVED_PARAMETERS),
+            "::",
+            stringify!(parameters)
+        )
+    );
+}
+#[doc = " Used with `encrypt` / `decrypt` with the [`AZIOT_KEYS_ENCRYPT_MECHANISM_AEAD`] mechanism."]
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS {
+    #[doc = " The IV."]
+    pub iv: *const ::std::os::raw::c_uchar,
+    #[doc = " The length of the `iv` buffer."]
+    pub iv_len: usize,
+    #[doc = " The AAD."]
+    pub aad: *const ::std::os::raw::c_uchar,
+    #[doc = " The length of the `aad` buffer."]
+    pub aad_len: usize,
+}
+#[test]
+fn bindgen_test_layout_AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS() {
+    assert_eq!(
+        ::std::mem::size_of::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>(),
+        32usize,
+        concat!("Size of: ", stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS))
+    );
+    assert_eq!(
+        ::std::mem::align_of::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>(),
+        8usize,
+        concat!(
+            "Alignment of ",
+            stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>())).iv as *const _ as usize
+        },
+        0usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS),
+            "::",
+            stringify!(iv)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>())).iv_len as *const _
+                as usize
+        },
+        8usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS),
+            "::",
+            stringify!(iv_len)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>())).aad as *const _ as usize
+        },
+        16usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS),
+            "::",
+            stringify!(aad)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS>())).aad_len as *const _
+                as usize
+        },
+        24usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS),
+            "::",
+            stringify!(aad_len)
+        )
+    );
+}
+#[doc = " Used with `encrypt` / `decrypt` with the [`AZIOT_KEYS_ENCRYPT_MECHANISM_DERIVED`] mechanism."]
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS {
+    #[doc = " The data used to derive the new key."]
+    pub derivation_data: *const ::std::os::raw::c_uchar,
+    #[doc = " The length of the `derivation_data` buffer."]
+    pub derivation_data_len: usize,
+    #[doc = " The encryption mechanism to use with the derived key."]
+    #[doc = ""]
+    #[doc = " One of the `AZIOT_KEYS_ENCRYPT_MECHANISM_*` constants."]
+    pub mechanism: AZIOT_KEYS_ENCRYPT_MECHANISM,
+    #[doc = " The parameters of the encryption mechanism specified by `mechanism`."]
+    pub parameters: *const ::std::os::raw::c_void,
+}
+#[test]
+fn bindgen_test_layout_AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS() {
+    assert_eq!(
+        ::std::mem::size_of::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>(),
+        32usize,
+        concat!(
+            "Size of: ",
+            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS)
+        )
+    );
+    assert_eq!(
+        ::std::mem::align_of::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>(),
+        8usize,
+        concat!(
+            "Alignment of ",
+            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>())).derivation_data
+                as *const _ as usize
+        },
+        0usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS),
+            "::",
+            stringify!(derivation_data)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>())).derivation_data_len
+                as *const _ as usize
+        },
+        8usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS),
+            "::",
+            stringify!(derivation_data_len)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>())).mechanism as *const _
+                as usize
+        },
+        16usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS),
+            "::",
+            stringify!(mechanism)
+        )
+    );
+    assert_eq!(
+        unsafe {
+            &(*(::std::ptr::null::<AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS>())).parameters as *const _
+                as usize
+        },
+        24usize,
+        concat!(
+            "Offset of field: ",
+            stringify!(AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS),
+            "::",
+            stringify!(parameters)
+        )
+    );
+}
+#[doc = " The algorithm of a key pair, as returned by `get_key_pair_parameter`."]
+#[doc = ""]
+#[doc = " One of the `AZIOT_KEYS_KEY_PAIR_PARAMETER_ALGORITHM_*` constants."]
+pub type AZIOT_KEYS_KEY_PAIR_PARAMETER_ALGORITHM = ::std::os::raw::c_uint;
+extern "C" {
+    #[doc = " Get the list of functions for operations corresponding to the specified version."]
+    #[doc = ""]
+    #[doc = " Implementations can use this function for initialization, since it is guaranteed to be called before any operations."]
+    #[doc = " However it is not an error to call this function multiple times, for the same or different version,"]
+    #[doc = " so implementations must ensure they only run their initialization once."]
+    #[doc = ""]
+    #[doc = " The pointer returned from this function must not be freed by the caller, and its contents must not be mutated."]
+    #[doc = ""]
+    #[doc = " # Errors"]
+    #[doc = ""]
+    #[doc = " - `AZIOT_KEYS_RC_ERR_INVALID_PARAMETER`:"]
+    #[doc = "   - `version` is not recognized by this implementation."]
+    #[doc = "   - `pfunction_list` is `NULL`."]
+    pub fn aziot_keys_get_function_list(
+        version: AZIOT_KEYS_VERSION,
+        pfunction_list: *mut *const AZIOT_KEYS_FUNCTION_LIST,
+    ) -> AZIOT_KEYS_RC;
+}
diff --git a/key/aziot-keys/aziot-keys.h b/key/aziot-keys/aziot-keys.h
index d7658d0..ccee1d7 100644
--- a/key/aziot-keys/aziot-keys.h
+++ b/key/aziot-keys/aziot-keys.h
@@ -26,7 +26,7 @@ typedef unsigned int AZIOT_KEYS_VERSION;
 /**
  * The base struct of all of function lists.
  */
-typedef struct {
+typedef struct AZIOT_KEYS_FUNCTION_LIST {
     /**
      * The version of the API represented in this function list.
      *
@@ -75,11 +75,11 @@ typedef unsigned int AZIOT_KEYS_ENCRYPT_MECHANISM;
 /**
  * The specific implementation of [`AZIOT_KEYS_FUNCTION_LIST`] for API version 2.0.0.0
  */
-typedef struct {
+typedef struct AZIOT_KEYS_FUNCTION_LIST_2_0_0_0 {
     /**
      * The value of `base.version` must be [`AZIOT_KEYS_VERSION_2_0_0_0`].
      */
-    AZIOT_KEYS_FUNCTION_LIST base;
+    struct AZIOT_KEYS_FUNCTION_LIST base;
     /**
      * Set a parameter on this library.
      *
@@ -392,7 +392,7 @@ typedef struct {
 /**
  * Used with `sign` / `verify` with the [`AZIOT_KEYS_SIGN_MECHANISM_DERIVED`] mechanism.
  */
-typedef struct {
+typedef struct AZIOT_KEYS_SIGN_DERIVED_PARAMETERS {
     /**
      * The data used to derive the new key.
      */
@@ -416,7 +416,7 @@ typedef struct {
 /**
  * Used with `encrypt` / `decrypt` with the [`AZIOT_KEYS_ENCRYPT_MECHANISM_AEAD`] mechanism.
  */
-typedef struct {
+typedef struct AZIOT_KEYS_ENCRYPT_AEAD_PARAMETERS {
     /**
      * The IV.
      */
@@ -438,7 +438,7 @@ typedef struct {
 /**
  * Used with `encrypt` / `decrypt` with the [`AZIOT_KEYS_ENCRYPT_MECHANISM_DERIVED`] mechanism.
  */
-typedef struct {
+typedef struct AZIOT_KEYS_ENCRYPT_DERIVED_PARAMETERS {
     /**
      * The data used to derive the new key.
      */
@@ -623,7 +623,7 @@ typedef unsigned int AZIOT_KEYS_KEY_PAIR_PARAMETER_ALGORITHM;
  *   - `pfunction_list` is `NULL`.
  */
 AZIOT_KEYS_RC aziot_keys_get_function_list(AZIOT_KEYS_VERSION version,
-                                           const AZIOT_KEYS_FUNCTION_LIST **pfunction_list);
+                                           const struct AZIOT_KEYS_FUNCTION_LIST **pfunction_list);
 
 
 
-- 
2.17.1

